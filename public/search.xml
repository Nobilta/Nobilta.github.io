<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>LeetCode#1024</title>
    <url>/2020/10/24/LeetCode-1024/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="LeetCode-1024求根到叶子节点数字之和"><a href="#LeetCode-1024求根到叶子节点数字之和" class="headerlink" title="LeetCode#1024求根到叶子节点数字之和"></a>LeetCode#1024求根到叶子节点数字之和</h2><a id="more"></a>
<p><a href="https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/" target="_blank" rel="noopener">题目链接</a><br>一道水题，主要是记录一下string居然也可以使用push_back() &amp; pop_back()<del>菜</del>，以及stoi、atoi函数（似乎并不是标准库中的函数，功能是将字符串转换成整数），stoi可以直接传入string类型的对象，而atoi只能传入char类型的数组。<br>附代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* node,<span class="keyword">int</span> &amp;ans,<span class="built_in">string</span> &amp;temp)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node -&gt; left == <span class="literal">nullptr</span> &amp;&amp; node -&gt; right == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            temp.push_back(node-&gt;val+<span class="string">'0'</span>);</span><br><span class="line">            <span class="keyword">int</span> num = stoi(temp);</span><br><span class="line">            ans+=num;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        temp.push_back(node-&gt;val+<span class="string">'0'</span>);</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;left!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            dfs(node-&gt;left,ans,temp);</span><br><span class="line">            temp.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;right!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            dfs(node-&gt;right,ans,temp);</span><br><span class="line">            temp.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">string</span> temp;</span><br><span class="line">        dfs(root,ans,temp);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#1002</title>
    <url>/2020/10/14/LeetCode-1002/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="LeetCode-1002查找常用字符"><a href="#LeetCode-1002查找常用字符" class="headerlink" title="LeetCode#1002查找常用字符"></a>LeetCode#1002查找常用字符</h2><a id="more"></a>
<p><a href="https://leetcode-cn.com/problems/find-common-characters/" target="_blank" rel="noopener">题目链接</a><br>这道题的题目用人话翻译一下就是给你几个字符串，让你找到在所有字符串中都出现过的字符，如果有一个字符在所有字符串中出现过很多次，不用去重。<del>力扣这个英译汉绝了</del><br>先说下我的想法，直接使用标记数组的方式，将每个字符串的字符分别存入map中，如果出现过这个字符，则数量+1，最后再遍历26个字母，逐一访问每个字符串的标记数组，即可获得按照字典序的结果，当然这个方式空间复杂度和时间复杂度都很高。<br>附代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">commonChars</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = A.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;&gt;ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; length ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;temp;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ;j &lt; A[i].<span class="built_in">size</span>() ; j++)</span><br><span class="line">                temp[A[i][j]]++;</span><br><span class="line">            ans.push_back(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">26</span> ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">min</span> = <span class="number">999</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; length ; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(ans[j][<span class="string">'a'</span>+i] &lt; <span class="built_in">min</span>)</span><br><span class="line">                    <span class="built_in">min</span> = ans[j][<span class="string">'a'</span>+i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">string</span> t;</span><br><span class="line">            t.push_back(<span class="string">'a'</span>+i);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; <span class="built_in">min</span> ; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                result.push_back(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>题解和我思路其实差不多，只不过它是维护了一个最小值数组，每次遍历字符串对它进行更新<br><del>（c++11的标准越来越像python了，乍一看差点以为挂错代码了）</del><br>附题解代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">commonChars</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">minfreq</span><span class="params">(<span class="number">26</span>, INT_MAX)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">freq</span><span class="params">(<span class="number">26</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="built_in">string</span>&amp; <span class="keyword">word</span>: A) &#123;<span class="comment">//遍历给定的A容器</span></span><br><span class="line">            <span class="built_in">fill</span>(freq.<span class="built_in">begin</span>(), freq.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> ch: <span class="keyword">word</span>) &#123;</span><br><span class="line">                ++freq[ch - <span class="string">'a'</span>];<span class="comment">//分别记录每个字符串的字符数量</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) &#123;<span class="comment">//维护记录每个字符最小数量的数组</span></span><br><span class="line">                minfreq[i] = <span class="built_in">min</span>(minfreq[i], freq[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; minfreq[i]; ++j) &#123;</span><br><span class="line">                ans.emplace_back(<span class="number">1</span>, i + <span class="string">'a'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>map</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#106</title>
    <url>/2020/09/26/LeetCode-106/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="LeetCode-106从中序与后序遍历序列构造二叉树"><a href="#LeetCode-106从中序与后序遍历序列构造二叉树" class="headerlink" title="LeetCode#106从中序与后序遍历序列构造二叉树"></a>LeetCode#106从中序与后序遍历序列构造二叉树</h2><a id="more"></a>
<p><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/" target="_blank" rel="noopener">题目链接</a><br>前序、中序、后序遍历是二叉树最常见的三种遍历方式，它们的详解和区别在这篇博客里写过。<br>我们想要通过中序和后序遍历来获取整个树形结构，大概过程是这样的：</p>
<ul>
<li>首先通过找规律我们能看出来，后序节点的最后一个即为根节点</li>
<li>我们在中序中找到根节点，就可以根据中节点来将中序分为左右两部分，而这两部分左右分别是根节点的左右子树</li>
<li>通过递归的方式，来不停缩小递归范围，最后找到左右子树皆为空的节点即为叶子节点<br>附代码（核心位置已经写了注释）：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> post;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder,<span class="keyword">int</span> pos1,<span class="keyword">int</span> pos2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cur;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = pos1 ; i &lt;= pos2 ; i ++)<span class="comment">//在限定中序搜索范围后，查找是否有当前的后序节点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[i] == postorder[post])</span><br><span class="line">            &#123;</span><br><span class="line">                cur = i;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="literal">false</span>)<span class="comment">//如果没找到当前后续节点，则该后序节点不在当前子树中</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode* node = <span class="keyword">new</span> TreeNode(postorder[post]);<span class="comment">//找到了之后返回当前节点</span></span><br><span class="line">        post--;<span class="comment">//找到后继续搜索下一个后序节点</span></span><br><span class="line">        node -&gt; right = dfs(inorder,postorder,cur + <span class="number">1</span>,pos2);</span><br><span class="line">        node -&gt; left = dfs(inorder,postorder,pos1,cur - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;    </span><br><span class="line">        post = inorder.<span class="built_in">size</span>()<span class="number">-1</span>;<span class="comment">//指向后序节点的指针，初始化为后序的最后一个节点</span></span><br><span class="line">        <span class="keyword">return</span> dfs(inorder,postorder,<span class="number">0</span>,inorder.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>题解</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#117</title>
    <url>/2020/09/28/LeetCode-117/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="LeetCode-117填充每个节点的下一个右侧节点指针-II"><a href="#LeetCode-117填充每个节点的下一个右侧节点指针-II" class="headerlink" title="LeetCode#117填充每个节点的下一个右侧节点指针 II"></a>LeetCode#117填充每个节点的下一个右侧节点指针 II</h2><a id="more"></a>
<p><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/" target="_blank" rel="noopener">题目链接</a><br>一开始让我想简单了，忽略了next节点可能是另一棵树上的可能性了<del>人傻了</del>，其实我们就可以简单理解为一个广度优先搜索，分别遍历每一层，在同一层时，当前节点的是上一个节点的next节点（第一个节点除外），我们可以每次把第一个节点作为空指针，让最后一个节点指向它。<br>附代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* left;</span></span><br><span class="line"><span class="comment">    Node* right;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() : val(0), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, Node* _left, Node* _right, Node* _next)</span></span><br><span class="line"><span class="comment">        : val(_val), left(_left), right(_right), next(_next) &#123;&#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        root -&gt; next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;Node*&gt;qu;</span><br><span class="line">        qu.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!qu.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> length = qu.<span class="built_in">size</span>();</span><br><span class="line">            Node* old = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; length ; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Node* temp = qu.front();</span><br><span class="line">                qu.pop();</span><br><span class="line">                <span class="keyword">if</span>(temp -&gt; left != <span class="literal">nullptr</span>)</span><br><span class="line">                    qu.push(temp -&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(temp -&gt; right != <span class="literal">nullptr</span>)</span><br><span class="line">                    qu.push(temp -&gt; right);</span><br><span class="line">                <span class="keyword">if</span>(i != <span class="number">0</span>)</span><br><span class="line">                    old -&gt; next = temp;</span><br><span class="line">                old = temp;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">return</span> root; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>bfs</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#404</title>
    <url>/2020/09/19/LeetCode-404/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="LeetCode-404左叶子子之和"><a href="#LeetCode-404左叶子子之和" class="headerlink" title="LeetCode#404左叶子子之和"></a>LeetCode#404左叶子子之和</h2><a id="more"></a>
<p><a href="https://leetcode-cn.com/problems/sum-of-left-leaves/" target="_blank" rel="noopener">题目链接</a><br>深搜遍历每个节点，判断一下是否为左叶子节点即可，没啥好说的，我是用一个标记flag来记录是否为左节点的，如果不是则直接继续遍历<br>附代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* node,<span class="keyword">long</span> <span class="keyword">long</span> &amp;ans,<span class="keyword">int</span> flag)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(node -&gt; left == <span class="literal">nullptr</span> &amp;&amp;  node -&gt; right == <span class="literal">nullptr</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    ans+=node -&gt; val;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">if</span>(node -&gt; left != <span class="literal">nullptr</span>)</span><br><span class="line">                dfs(node-&gt;left,ans,<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(node -&gt; right != <span class="literal">nullptr</span>)</span><br><span class="line">                dfs(node-&gt;right,ans,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(node -&gt; left != <span class="literal">nullptr</span>)</span><br><span class="line">                dfs(node-&gt;left,ans,<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(node -&gt; right != <span class="literal">nullptr</span>)</span><br><span class="line">                dfs(node-&gt;right,ans,<span class="number">0</span>);            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        dfs(root,ans,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>深搜</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#18</title>
    <url>/2020/10/06/LeetCode-18/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="LeetCode-18四数之和"><a href="#LeetCode-18四数之和" class="headerlink" title="LeetCode#18四数之和"></a>LeetCode#18四数之和</h2><a id="more"></a>
<p><a href="https://leetcode-cn.com/problems/4sum/" target="_blank" rel="noopener">题目链接</a><br>其实这道题本质上就是一个四层循环判断所有可能性…还以为题解有什么高深的算法呢<del>(逃</del><br>为了避免有重复的结果出现，我们首先需要进行排序，然后如果是相同的数看作一种情况，为了降低时间复杂度，题解进行了几个剪枝：首先把所有大于的情况直接break掉，然后是在剩两个数的时候做了一个双指针，如果小于结果，就只判断左指针的右侧，如果大于结果，就只判断右指针的左侧<br>附代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">fourSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; quadruplets;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() &lt; <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> quadruplets;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());<span class="comment">//先排序</span></span><br><span class="line">        <span class="keyword">int</span> length = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length - <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;<span class="comment">//相邻的两个数相同看作同一种情况，每层循环都需要判断</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] + nums[i + <span class="number">1</span>] + nums[i + <span class="number">2</span>] + nums[i + <span class="number">3</span>] &gt; target) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] + nums[length - <span class="number">3</span>] + nums[length - <span class="number">2</span>] + nums[length - <span class="number">1</span>] &lt; target) &#123;<span class="comment">//两个if进行第一层剪枝，下同</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; length - <span class="number">2</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] + nums[j + <span class="number">1</span>] + nums[j + <span class="number">2</span>] &gt; target) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] + nums[length - <span class="number">2</span>] + nums[length - <span class="number">1</span>] &lt; target) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> left = j + <span class="number">1</span>, right = length - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (left &lt; right) &#123;<span class="comment">//使用双指针，逐渐逼近正确范围</span></span><br><span class="line">                    <span class="keyword">int</span> sum = nums[i] + nums[j] + nums[left] + nums[right];</span><br><span class="line">                    <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">                        quadruplets.push_back(&#123;nums[i], nums[j], nums[left], nums[right]&#125;);</span><br><span class="line">                        <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) &#123;</span><br><span class="line">                            left++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        left++;</span><br><span class="line">                        <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) &#123;</span><br><span class="line">                            right--;</span><br><span class="line">                        &#125;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> quadruplets;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#37</title>
    <url>/2020/09/15/LeetCode-37/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="LeetCode-37解数独"><a href="#LeetCode-37解数独" class="headerlink" title="LeetCode#37解数独"></a>LeetCode#37解数独</h2><a id="more"></a>
<p><a href="https://leetcode-cn.com/problems/sudoku-solver/" target="_blank" rel="noopener">题目链接</a></p>
<p>一道暴力的深搜就能过的题，按照数独的规则，在安放一个数的时候需要分别考虑横向、纵向以及当前位置所在的九宫格。我们可以先遍历一遍题目给出的图，分别统计出空格的位置，每一行、每一列以及每个小九宫格中已经存在的数据，然后以空格数量作为循环变量，当空格没有全部用完则继续往下一层递归，直到找到所有答案为止。为了提高递归回溯的速度，我们还可以设置一个标记判断是否已经找到其中一种解，只要找到了则停止递归。<br>附上代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">bool</span> <span class="built_in">line</span>[<span class="number">9</span>][<span class="number">9</span>];<span class="comment">//行标记数组，第一维代表是第几行，第二维代表这个数字是否存在，下面两个数组相同</span></span><br><span class="line">    <span class="keyword">bool</span> col[<span class="number">9</span>][<span class="number">9</span>];<span class="comment">//列标记数组</span></span><br><span class="line">    <span class="keyword">bool</span> flag[<span class="number">3</span>][<span class="number">3</span>][<span class="number">9</span>];<span class="comment">//九宫格标记数组</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt;nums;<span class="comment">//储存所有需要填数字的空格</span></span><br><span class="line">    <span class="keyword">bool</span> ans = <span class="literal">false</span>;<span class="comment">//判断是否已经找到一个答案的标记</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board,<span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos &gt;= nums.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            ans = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> [x,y] = nums[pos];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">9</span> ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="keyword">if</span>(!<span class="built_in">line</span>[x][i] &amp;&amp; !col[y][i] &amp;&amp; !flag[x/<span class="number">3</span>][y/<span class="number">3</span>][i] &amp;&amp; !ans)</span><br><span class="line">           &#123;</span><br><span class="line">               board[x][y] = i + <span class="number">1</span> + <span class="string">'0'</span>;</span><br><span class="line">               <span class="built_in">line</span>[x][i] = col[y][i] = flag[x/<span class="number">3</span>][y/<span class="number">3</span>][i] = <span class="literal">true</span>;</span><br><span class="line">               dfs(board,pos+<span class="number">1</span>);</span><br><span class="line">               <span class="built_in">line</span>[x][i] = col[y][i] = flag[x/<span class="number">3</span>][y/<span class="number">3</span>][i] = <span class="literal">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">9</span> ; i++)<span class="comment">//先遍历一遍数组找到所有已知信息</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; <span class="number">9</span> ; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">'.'</span>)</span><br><span class="line">                    nums.push_back(pair(i,j));</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">int</span> num = board[i][j]-<span class="string">'0'</span><span class="number">-1</span>;<span class="comment">//存储表是从0开始，所以需要减1</span></span><br><span class="line">                        <span class="built_in">line</span>[i][num] = <span class="literal">true</span>;</span><br><span class="line">                        col[j][num] = <span class="literal">true</span>;</span><br><span class="line">                        flag[i/<span class="number">3</span>][j/<span class="number">3</span>][num] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(board,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>深搜</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#2</title>
    <url>/2020/10/04/LeetCode-2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="LeetCode-2两数相加"><a href="#LeetCode-2两数相加" class="headerlink" title="LeetCode#2两数相加"></a>LeetCode#2两数相加</h2><a id="more"></a>
<p><a href="https://leetcode-cn.com/problems/add-two-numbers/" target="_blank" rel="noopener">题目链接</a><br>一道用链表存储每一位数，然后按位相加的题目，遍历起来没有任何难度，主要是需要注意循环结束的条件：</p>
<ul>
<li>第一个和第二个链表都到了末尾（都到了末尾才相当于把两个‘数’都遍历了一遍，只有一个指向nullptr时不行的）</li>
<li>自定义的进位位需要为0（因为两个数相加可能会产生进位的情况，如果我们只考虑是否把两个已知链表遍历完了，那么可能最后会少一位）<br>其他就没什么难点了，无非是处理链表遍历的时候，如何声明新的节点和访问next节点（要避免不越界）<br>附代码：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* ans = <span class="literal">nullptr</span>;<span class="comment">//我们返回的答案head节点，声明的时候可以先声明为空</span></span><br><span class="line">        <span class="keyword">int</span> inc = <span class="number">0</span>;<span class="comment">//记录是否有进位</span></span><br><span class="line">        <span class="keyword">int</span> val = <span class="number">0</span>;<span class="comment">//记录当天两个链表相加的值</span></span><br><span class="line">        ListNode* cur = <span class="literal">nullptr</span>;<span class="comment">//遍历时需要用到的temp节点，也可以看作是链表中的tail节点吧？</span></span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="literal">nullptr</span> || l2 != <span class="literal">nullptr</span> || inc != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x1,x2;</span><br><span class="line">            <span class="keyword">if</span>(l1 == <span class="literal">nullptr</span>)<span class="comment">//如果其中一个链表已经到了末尾（空节点），直接将val看作0即可</span></span><br><span class="line">                x1 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                x1 = l1 -&gt; val;</span><br><span class="line">                l1 = l1 -&gt; next;<span class="comment">//访问这个链表的下一个节点</span></span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">if</span>(l2 == <span class="literal">nullptr</span>)<span class="comment">//同上</span></span><br><span class="line">                x2 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                x2 = l2 -&gt; val;</span><br><span class="line">                l2 = l2 -&gt; next;</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">            val = x1 + x2 + inc;<span class="comment">//别忘了处理进位</span></span><br><span class="line">            inc = val/<span class="number">10</span>;</span><br><span class="line">            val %= <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span>(ans == <span class="literal">nullptr</span>)<span class="comment">//在第一个head节点需要额外单独处理一下</span></span><br><span class="line">            &#123;</span><br><span class="line">                ans = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">                cur = ans;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                cur -&gt; next = <span class="keyword">new</span> ListNode(val);<span class="comment">//相当于处理tail节点</span></span><br><span class="line">                cur = cur -&gt; next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#40</title>
    <url>/2020/09/11/LeetCode-40/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="LeetCode-40组合总和Ⅱ"><a href="#LeetCode-40组合总和Ⅱ" class="headerlink" title="LeetCode#40组合总和Ⅱ"></a>LeetCode#40组合总和Ⅱ</h2><a id="more"></a>
<h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><p>给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p>
<p>candidates 中的每个数字在每个组合中只能使用一次。</p>
<p>说明：</p>
<p>所有数字（包括目标数）都是正整数。<br>解集不能包含重复的组合。<br>来源：力扣（LeetCode）<br><a href="https://leetcode-cn.com/problems/combination-sum-ii" target="_blank" rel="noopener">链接</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;ans;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;temp;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates,<span class="keyword">int</span> target,<span class="keyword">int</span> pos,<span class="keyword">int</span> sum)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum == target)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; ans.<span class="built_in">size</span>() ; i ++)<span class="comment">//判断当前找到的vector是否已经存在了</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(temp == ans[i])</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(temp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum &gt; target)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(pos &gt;= candidates.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        temp.push_back(candidates[pos]);</span><br><span class="line">        dfs(candidates,target,pos+<span class="number">1</span>,sum+candidates[pos]);</span><br><span class="line">        temp.pop_back();</span><br><span class="line">        dfs(candidates,target,pos+<span class="number">1</span>,sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">combinationSum2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        sort(candidates.<span class="built_in">begin</span>(),candidates.<span class="built_in">end</span>());<span class="comment">//首先对数组进行排序</span></span><br><span class="line">        dfs(candidates,target,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这本来是一道很简单的递归回溯问题，但是因为题目要求不能包含重复的题解，所以对于我这个菜鸡一下就难了起来…通过对stl库的了解发现，sort是可以直接用来排序简单形式的vector的（按照字典序排列），且vector本身是可以使用标准运算符（如== &gt; &lt;等等进行比较的，仅限简单数据类型）<br>（鸽了好久的博客终于要开始更了）<br><del>（咕咕咕）</del></p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>回溯</tag>
        <tag>vector</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#46、#47</title>
    <url>/2020/09/18/LeetCode-46%E3%80%81-47/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="LeetCode-46、-47全排列"><a href="#LeetCode-46、-47全排列" class="headerlink" title="LeetCode#46、#47全排列"></a>LeetCode#46、#47全排列</h2><a id="more"></a>
<p><a href="https://leetcode-cn.com/problems/permutations/" target="_blank" rel="noopener">#46</a><br><a href="https://leetcode-cn.com/problems/permutations-ii/" target="_blank" rel="noopener">#47</a><br>今天的每日一题是一个全排列的升级版，突然发现忘记了全排列怎么写..<del>（菜）</del><br>就顺便做了46题，裸的全排列，记录一下思路。</p>
<p>先看裸的全排列，我们直接想到的就是直接分别以每一个数为第一个数，遍历所有的可能性，但是因为我们不知道数组中有多少个数，所以我们就没法确定要写多少层的循环<del>也不是能写</del>所以这时候我们就需要用到深搜/广搜的想法，通过递归和回溯的方法来进行基本的遍历。</p>
<p>为了避免重复，我们可以写一个标记数组来记录在当前的递归中这个数是否已经使用过，然后再回溯的时候再取消标记，当然对于这种简单的递归我们也可以省去一点空间复杂度，直接当遍历到第pos个数的时候和当前循环中的第i个数进行交换，以达到全排列的效果。其原理是我们可以把从0-pos的数认为是已经选择过的，pos+1-size()-1即为未选择过的</p>
<p>#46代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;&amp;ans,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;nums,<span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos == nums.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            ans.push_back(nums);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = pos ; i &lt; nums.<span class="built_in">size</span>() ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            swap(nums[i],nums[pos]);</span><br><span class="line">            dfs(ans,nums,pos+<span class="number">1</span>);</span><br><span class="line">            swap(nums[i],nums[pos]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">permute</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;ans;</span><br><span class="line">        dfs(ans,nums,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>#47和#46的区别就是给定的数组中可能存在相同的数字，这样就导致我们如果照常进行全排列遍历就有可能出现重复的情况，我用的是一个比较笨的方法，直接使用set容器来进行去重（set毕竟是基于红黑树的操作，速度还是很快<del>（慢）</del><br>的，这样的结果就是时间复杂度和空间复杂度都很高，但是方便。还有一种方法，先使用sort对给定的数组进行排序，这样在递归回溯过程中就可以进行判断，配合标记数组，时间复杂度会快很多，但是由于我没写明白所以…建议去看题解<del>(逃)</del></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;flag,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;&amp;ans,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;nums,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;temp,<span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos == nums.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            ans.push_back(temp);</span><br><span class="line">            <span class="keyword">return</span>;        </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.<span class="built_in">size</span>() ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!flag[i])</span><br><span class="line">&#123;            flag[i] = <span class="number">1</span>;</span><br><span class="line">            temp.push_back(nums[i]);</span><br><span class="line">            dfs(flag,ans,nums,temp,pos+<span class="number">1</span>);</span><br><span class="line">            flag[i] = <span class="number">0</span>;</span><br><span class="line">            temp.pop_back();&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">permuteUnique</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;ans;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;flag(nums.<span class="built_in">size</span>(),<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;temp;</span><br><span class="line">        dfs(flag,ans,nums,temp,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;s;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;::iterator it;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;ansr;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i  = <span class="number">0</span> ; i &lt; ans.<span class="built_in">size</span>() ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            s.insert(ans[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(it = s.<span class="built_in">begin</span>() ; it != s.<span class="built_in">end</span>() ;it++)</span><br><span class="line">        &#123;</span><br><span class="line">            ansr.push_back(*it);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ansr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>深搜</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#474</title>
    <url>/2020/09/12/LeetCode-474/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="LeetCode-474一和零"><a href="#LeetCode-474一和零" class="headerlink" title="LeetCode#474一和零"></a>LeetCode#474一和零</h2><a id="more"></a>
<p><a href="https://leetcode-cn.com/problems/ones-and-zeroes/" target="_blank" rel="noopener">链接</a><br>三维动规，可以循环判断每一个包含的字符串从而进行空间优化，注意在动规的时候需要从后往前找（即从m-&gt;cnt1,n-&gt;cnt2，从前往后会影响之前的状态<del>改了好久，菜啊</del>）动态规划可太快乐了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">200</span>][<span class="number">200</span>];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMaxForm</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; strs.<span class="built_in">size</span>() ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> cnt1 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> cnt2 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j  = <span class="number">0</span> ; j &lt; strs[i].<span class="built_in">size</span>() ; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(strs[i][j] == <span class="string">'0'</span>)</span><br><span class="line">                    cnt1++;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    cnt2++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = m ; j &gt;= cnt1 ;j --)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = n ; k &gt;= cnt2 ; k --)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[j][k] = <span class="built_in">max</span>(dp[j][k],dp[j-cnt1][k-cnt2]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#141</title>
    <url>/2020/10/09/LeetCode-141/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="LeetCode-141环形链表"><a href="#LeetCode-141环形链表" class="headerlink" title="LeetCode#141环形链表"></a>LeetCode#141环形链表</h2><a id="more"></a>
<p><a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">题目链接</a><br>一道链表问题，通俗来说就是判断一个链表中是否有环<del>力扣的翻译真绝了</del>，除了开辟额外，如使用哈希表等等，还有其他的方式吗？那为了不开辟额外的空间，我们需要引入一个新的指针方式：快慢指针。<br>顾名思义，快慢指针就是两个指针，一个跑的快，一个跑得慢，它是在链表中检测是否有环的一个重要方式，具体实现方式是：声明两个指针，接下来进行循环，快指针每次步进两下，慢指针每次步进一下，如果遇到空指针那么肯定是找到了链表结尾，没有环，而如果快指针最终追上了慢指针（两个指针相遇），那么就一定是在链表中存在环。具体原理可以使用严谨的数学公式进行推导…而使用的话，我们只需要类比在操场跑圈即可：如果都围着操场跑步，那么跑得快的同学总会有追上跑的慢的同学的时候（扣圈），但是如果在直道上，跑步速度不同的两个同学是永远不会相遇的。<br>附代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || head -&gt; next == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        ListNode* fast = head -&gt; next;<span class="comment">//快指针</span></span><br><span class="line">        ListNode* slow = head;<span class="comment">//慢指针</span></span><br><span class="line">        <span class="keyword">while</span>(fast != slow)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(fast -&gt; next == <span class="literal">nullptr</span> || fast -&gt; next -&gt; next == <span class="literal">nullptr</span> || slow -&gt; next == <span class="literal">nullptr</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            fast = fast -&gt; next -&gt; next;</span><br><span class="line">            slow = slow -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#701</title>
    <url>/2020/09/30/LeetCode-701/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="LeetCode-701二叉搜索树中的插入操作"><a href="#LeetCode-701二叉搜索树中的插入操作" class="headerlink" title="LeetCode#701二叉搜索树中的插入操作"></a>LeetCode#701二叉搜索树中的插入操作</h2><a id="more"></a>
<p><a href="https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/" target="_blank" rel="noopener">链接</a><br>因为是二叉搜索树，所以遍历起来十分的简单，我是使用递归实现的，如果当前节点的值大于给定值，就找右子树，反之找左子树（题目说了不包含重复的情况），如果找到空节点就，就把给定值新建一个节点进行连接<del>我觉得还是很简单的，就是复杂度有点高。。。。</del><br>附代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root,<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; root -&gt; val &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">if</span>(val &gt; root -&gt; val)</span><br><span class="line">           &#123;</span><br><span class="line">            <span class="keyword">if</span>(root -&gt; right == <span class="literal">nullptr</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                root -&gt; right = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            dfs(root -&gt; right,val);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">if</span>(root -&gt; left == <span class="literal">nullptr</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                root -&gt; left = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            dfs(root -&gt; left,val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">insertIntoBST</span><span class="params">(TreeNode* root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">        dfs(root,val);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#75</title>
    <url>/2020/10/07/LeetCode-75/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="LeetCode-75颜色分类"><a href="#LeetCode-75颜色分类" class="headerlink" title="LeetCode#75颜色分类"></a>LeetCode#75颜色分类</h2><a id="more"></a>
<p><a href="https://leetcode-cn.com/problems/sort-colors/" target="_blank" rel="noopener">题目链接</a><br>刚看题的时候还以为是个简单的双层暴力循环（比如冒泡或者选择排序），但是题目要求说不能有额外的空间复杂度且只能遍历一次emmmmmmm，后来<del>想到了</del>双指针的写法，一个代表0，一个代表1，只要把0和1都挪到最前面，那剩下的自然就是2了。<br>具体做法是，一个指针指向应该放0的位置，一个指针指向应该放1的位置，如果在遍历过程中找到了0或者1，则和相应的指针进行交换，同时这个指针向前移动。思路很简单，但是中间有一些细节需要处理：如果在找到一个0的时候，这个位置上已经是确定的1的位置（即1的指针已经遍历过了），那么直接进行交换就会让当前这个已经确定位置的1产生错误。如果当前p0指针位置是1，我们可以先把需要交换的0交换到p0，再把这个1交换到p1。至于如何判断是否发生了这种情况，我们可以判断p1是否大于p0，如果大于则一定发生<del>（不明白在纸上划拉两下就懂了）</del><br>附代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> p0 = <span class="number">0</span>,p1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; length ; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(p1 &gt; p0)</span><br><span class="line">                &#123;</span><br><span class="line">                    swap(nums[i],nums[p0]);</span><br><span class="line">                    swap(nums[i],nums[p1]);</span><br><span class="line">                    p0++;</span><br><span class="line">                    p1++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    swap(nums[i],nums[p0]);</span><br><span class="line">                    p0++;</span><br><span class="line">                    p1++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                swap(nums[i],nums[p1]);</span><br><span class="line">                p1++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#771</title>
    <url>/2020/10/02/LeetCode-771/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="LeetCode-771宝石与石头"><a href="#LeetCode-771宝石与石头" class="headerlink" title="LeetCode#771宝石与石头"></a>LeetCode#771宝石与石头</h2><a id="more"></a>
<p><a href="https://leetcode-cn.com/problems/jewels-and-stones/" target="_blank" rel="noopener">题目链接</a><br>特别水特别水的一道题，我主要是为了记录哈希表怎么使用的<del>不得不说哈希表真的快，击败100%</del><br>附代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numJewelsInStones</span><span class="params">(<span class="built_in">string</span> J, <span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length1 = J.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> length2 = S.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;ha;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; length2 ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ha[S[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; length1 ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt+=ha[J[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#78</title>
    <url>/2020/09/20/LeetCode-78/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="LeetCode-78子集"><a href="#LeetCode-78子集" class="headerlink" title="LeetCode#78子集"></a>LeetCode#78子集</h2><a id="more"></a>
<p><a href="https://leetcode-cn.com/problems/subsets/submissions/" target="_blank" rel="noopener">题目链接</a><br>一道基础的回溯题<del>(这几天怎么都是回溯)</del>与全排列问题类似，区别是需要在每一次遍历的时候分别保存结果，而不是当找到nums.size()的时候再保存结果<br>附代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; ans,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;temp,<span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos == nums.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = pos ; i &lt; nums.<span class="built_in">size</span>() ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            temp.push_back(nums[i]);</span><br><span class="line">            ans.push_back(temp);</span><br><span class="line">            dfs(nums,ans,temp,i+<span class="number">1</span>);</span><br><span class="line">            temp.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">subsets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;ans;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;temp;</span><br><span class="line">        ans.push_back(temp);</span><br><span class="line">        dfs(nums,ans,temp,<span class="number">0</span>);   </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>深搜</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#79</title>
    <url>/2020/09/13/LeetCode-79/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="LeetCode-79单词搜索"><a href="#LeetCode-79单词搜索" class="headerlink" title="LeetCode#79单词搜索"></a>LeetCode#79单词搜索</h2><a id="more"></a>
<p><a href="https://leetcode-cn.com/problems/word-search/submissions/" target="_blank" rel="noopener">题目链接</a><br>一道看似简单深搜回溯,需要注意在回溯过程中判断结束回溯的条件(图的边界,字符串长度)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> flag[<span class="number">205</span>][<span class="number">205</span>];</span><br><span class="line">    <span class="keyword">bool</span> ans = <span class="literal">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="built_in">string</span>&amp; <span class="keyword">word</span>,<span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function">    </span>&#123;   </span><br><span class="line">        <span class="comment">//cout &lt;&lt; x &lt;&lt; y &lt;&lt; word &lt;&lt; pos &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">0</span> </span><br><span class="line">        || x &gt;= board.<span class="built_in">size</span>() </span><br><span class="line">        || y &lt; <span class="number">0</span> </span><br><span class="line">        || y &gt;= board[<span class="number">0</span>].<span class="built_in">size</span>() </span><br><span class="line">        || board[x][y] != <span class="keyword">word</span>[pos] </span><br><span class="line">        || flag[x][y] ==<span class="number">1</span></span><br><span class="line">        || ans == <span class="literal">true</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; board[x][y] &lt;&lt; " " &lt;&lt; x &lt;&lt; " " &lt;&lt; y  &lt;&lt; " "  &lt;&lt; pos &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">if</span>(flag[x][y] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(pos == <span class="keyword">word</span>.<span class="built_in">size</span>() - <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ans = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            flag[x][y] = <span class="number">1</span>;</span><br><span class="line">            dfs(board,x+<span class="number">1</span>,y,<span class="keyword">word</span>,pos+<span class="number">1</span>);</span><br><span class="line">            dfs(board,x<span class="number">-1</span>,y,<span class="keyword">word</span>,pos+<span class="number">1</span>);</span><br><span class="line">            dfs(board,x,y+<span class="number">1</span>,<span class="keyword">word</span>,pos+<span class="number">1</span>);</span><br><span class="line">            dfs(board,x,y<span class="number">-1</span>,<span class="keyword">word</span>,pos+<span class="number">1</span>);</span><br><span class="line">            flag[x][y] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span> <span class="keyword">word</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; board.<span class="built_in">size</span>() ; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].<span class="built_in">size</span>() ; j++)</span><br><span class="line">                dfs(board,i,j,<span class="keyword">word</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>传递形参时,会在栈内重新构建数组,传引用则不会(或使用全局数组),二者在空间和时间复杂度上都差很多</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>深搜</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#763</title>
    <url>/2020/10/22/LeetCode-763/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="LeetCode-763划分字母区间"><a href="#LeetCode-763划分字母区间" class="headerlink" title="LeetCode#763划分字母区间"></a>LeetCode#763划分字母区间</h2><a id="more"></a>
<p><a href="https://leetcode-cn.com/problems/partition-labels/" target="_blank" rel="noopener">题目链接</a><br>先说我的解法吧，使用一个可以把字符类型和布尔类型对应上的stl储存这段中是否已经遇到了当前这个字符，如果遇到了则直接跳过找继续遍历字符串（因为第一次找的时候记录的就是这个字符的最后一次出现的位置），如果遍历到当前字符串的最长距离（也就是当前这个串中，所有的出现过的字符中的最后一个）也就是找到了当前的这个字符串。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">partitionLabels</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">bool</span>&gt;hash;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;ans;</span><br><span class="line">        <span class="keyword">int</span> longest = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; S.<span class="built_in">size</span>() ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(hash[S[i]] == <span class="literal">false</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                hash[S[i]] == <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = S.<span class="built_in">size</span>() - <span class="number">1</span> ; j &gt;longest ; j--)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(S[j] == S[i])</span><br><span class="line">                        longest = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i == longest)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//cout &lt;&lt; longest &lt;&lt; " " &lt;&lt; start &lt;&lt; endl;</span></span><br><span class="line">                ans.push_back(longest-start+<span class="number">1</span>);</span><br><span class="line">                longest++;</span><br><span class="line">                start=longest;</span><br><span class="line">                hash.<span class="built_in">clear</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我的思路和题解思路差不多<del>(假装</del>，但是不管是开一个哈希表还是一个map都需要开辟额外的空间，题解直接用了双指针的方式降低了空间复杂度（当然直接访问数组的时间复杂度肯定也比哈希表快），附代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">partitionLabels</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> last[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">int</span> length = S.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            last[S[i] - <span class="string">'a'</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; partition;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, <span class="built_in">end</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="built_in">end</span> = <span class="built_in">max</span>(<span class="built_in">end</span>, last[S[i] - <span class="string">'a'</span>]);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="built_in">end</span>) &#123;</span><br><span class="line">                partition.push_back(<span class="built_in">end</span> - start + <span class="number">1</span>);</span><br><span class="line">                start = <span class="built_in">end</span> + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> partition;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#84</title>
    <url>/2020/09/14/LeetCode-84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="LeetCode-84柱状图中最大的矩形"><a href="#LeetCode-84柱状图中最大的矩形" class="headerlink" title="LeetCode#84柱状图中最大的矩形"></a>LeetCode#84柱状图中最大的矩形</h2><a id="more"></a>
<p><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener">题目链接</a></p>
<p>单调栈顾名思义，是单调的栈<br><del>（这不废话吗）</del>，即栈内的所有元素都为单调递增或递减的。单调栈看似简单，但是在实际应用中可以通过O(n)的时间复杂度来完成很多复杂的遍历。</p>
<p>以这道题来说，看到题目后我第一想法是直接暴力遍历，挨个遍历每一个矩形，然后分别往左右进行扩展，找到相邻的所有高度大于当前矩形的矩形，进而求出大矩形的宽度，但是这样的时间复杂度会达到一个爆炸的状态（尤其数据比较恶心且数据量很大的时候），极有可能会t。</p>
<p>这时候就轮到单调栈来登场了，先放上我学习单调栈用到的<a href="https://blog.csdn.net/Zolewit/article/details/88863970" target="_blank" rel="noopener">链接</a>，我们还是分别以每一个矩形的高度作为高，但是这次我们只需要遍历一次就可以得到所有高度的最大矩形。原文作者已经讲的很清晰了，我在此基础上再补充一些我在自己做这道题过程中的一点理解。</p>
<p>先附上自己写的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">       heights.push_back(<span class="number">0</span>);</span><br><span class="line">       <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;sta;</span><br><span class="line">       <span class="keyword">int</span> maxnum = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; heights.<span class="built_in">size</span>() ; i++)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">while</span>(!sta.empty() &amp;&amp; heights[i] &lt; heights[sta.top()])</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">int</span> top = sta.top();</span><br><span class="line">               sta.pop();</span><br><span class="line">               <span class="keyword">if</span>(sta.empty())</span><br><span class="line">                maxnum = <span class="built_in">max</span>(maxnum,heights[top]*i);</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">               maxnum = <span class="built_in">max</span>(maxnum,heights[top] * (i - (sta.top() + <span class="number">1</span>)));</span><br><span class="line">           &#125;</span><br><span class="line">           sta.push(i);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> maxnum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>在计算宽度的时候为什么要区分每一个矩形的左右边沿？因为heights数组是从0开始的，且每一个矩形是有自身的宽度的，不能简单的看作一个点或者一条线，而在计算宽度的时候这些都是要考虑进去的，比如第三个矩形到第一个矩形实际宽度应该是3，而如果简单的用矩形的编号相减（2-0）很明显是错误的。</p>
</li>
<li><p>为什么要给heights数组的结尾推入一个0？我个人理解是求得的每个高度所构成的最大矩形面积实际是在栈顶元素弹出时进行求解的，所以需要弹出每一个栈内元素之后才相当于遍历完成，否则会缺少条件。</p>
</li>
<li><p>结合代码和上一条分析来看，也就能一下明白了为什么在计算面积时使用的高度为heights[top]而不是heights[i]了。换言之就是当遇到比栈顶小的height，就是栈顶这个高度的矩形的宽不能再往右扩了，而因为我们采用的单调栈保证了栈内元素的单调递增，所以相当于也限定了这个高度的左侧宽度到哪里<br><del>（我在这卡了好久想不明白，还是菜啊）</del></p>
</li>
</ul>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#968</title>
    <url>/2020/09/22/LeetCode-968/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="LeetCode-968监控二叉树"><a href="#LeetCode-968监控二叉树" class="headerlink" title="LeetCode#968监控二叉树"></a>LeetCode#968监控二叉树</h2><a id="more"></a>
<p><a href="https://leetcode-cn.com/problems/binary-tree-cameras/" target="_blank" rel="noopener">题目链接</a></p>
<p>一道在树上的dp问题，因为是树所以我们比较能简单的想到使用递归回溯的方法。（不停的遍历子节点，所以是递归回溯）而回溯的时候需要几种情况的参数，来辅助自己选择最小值。</p>
<p>三种情况：</p>
<ul>
<li>a：统计了整个树需要的摄像头数量，并且当前节点上安装了摄像头</li>
<li>b: 统计了整个树需要的最少摄像头数量，并且当前节点可以选择不安装摄像头（意思是如果它的两个子结点中有一个安装了摄像头，当前节点就不需要安装了，需要具体考虑并取最小值，这是我们需要的最终结果）</li>
<li>c: 统计了不考虑当前节点需要的最少摄像头数量（即只考虑它的子树需要的摄像头数量）</li>
</ul>
<p>我们假设当前节点的左右节点返回的结果分别为la、lb、lc、ra、rb、rc<br>那么我们就有如下结论：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; lc+rc+1 &#x2F;&#x2F;左节点上不安装摄像头+右节点不安装摄像头+一个当前节点安装的摄像头</span><br><span class="line">b &#x3D; min(a,min(la+rb,lb+ra)) &#x2F;&#x2F;两种情况，比较当前节点安装摄像头和当前节点不安装摄像头（如果当前节点不安装摄像头，那么它的子节点中必须有一个要安装摄像头，所以一定会选择la或ra，再加上另一棵树需要摄像头的最少情况）</span><br><span class="line">c &#x3D; min(a,lb+rb)&#x2F;&#x2F;因为不考虑当前节点是否被监控，所以我们只需要判断两个子树需要最少摄像头的和即可（之所以和a比较是因为存在当前节点为叶子（空）节点的情况，下面会继续讨论）</span><br></pre></td></tr></table></figure>
<p>那么如果当前节点为叶子节点呢？继续向下找的话，它的子节点都是空节点，空节点不能处于被选中的状态，所以空节点不存在a状态（即当前节点被选中安装摄像头）。但是为了方便递归回溯，我们采用统一的格式，所以为了避免出现错误的给空节点设置成a的情况，我们可以将空节点的初值调成特别大，这样就解决了空节点不能被选中的情况。</p>
<p>解决了这几个关键的问题，整个问题也就迎刃而解了，附一个代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">status</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">int</span> a,b,c;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">status <span class="title">dfs</span><span class="params">(TreeNode *node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="number">999999</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> [la,lb,lc] = dfs(node-&gt;left);</span><br><span class="line">        <span class="keyword">auto</span> [ra,rb,rc] = dfs(node-&gt;right);</span><br><span class="line">        <span class="keyword">int</span> a = lc+rc+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="built_in">min</span>(a,<span class="built_in">min</span>(ra+lb,rb+la));</span><br><span class="line">        <span class="keyword">int</span> c = <span class="built_in">min</span>(a,lb+rb);</span><br><span class="line">        <span class="comment">//cout &lt;&lt; a &lt;&lt; b &lt;&lt; c &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">return</span> &#123;a,b,c&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCameraCover</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> [a,b,c] = dfs(root);</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>回溯</tag>
        <tag>树状动归</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#94</title>
    <url>/2020/09/14/LeetCode-94/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="LeetCode-94二叉树的中序遍历"><a href="#LeetCode-94二叉树的中序遍历" class="headerlink" title="LeetCode#94二叉树的中序遍历"></a>LeetCode#94二叉树的中序遍历</h2><a id="more"></a>
<p><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">题目链接</a></p>
<p>二叉树的中序遍历，首先我们来看一下二叉树的前序（VLR）、中序（LDR）、后序（LRD）遍历的定义:</p>
<p>前序遍历：先访问根节点，再遍历左子树，最后遍历右子树</p>
<p>中序遍历：先遍历左子树，再访问根节点，最后遍历右子树</p>
<p>后序遍历：先遍历左子树，再访问右子树，最后访问根节点</p>
<p>有了三种遍历的定义，我们在举个例子具体看一下：<br><img src="/images/erchashu.png" alt=""></p>
<p>先序遍历：123564</p>
<p>中序遍历：153624</p>
<p>后续遍历：563421</p>
<p>结合这个具体的例子是不是就理解了呢？</p>
<p>理解了中序遍历，代码就很好理解了，先判断当前节点是否右左子树，如果有则继续遍历，没有则直接将当前节点存入答案，最后再遍历右子树。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;ans;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span>(node -&gt;left != <span class="literal">nullptr</span>)</span><br><span class="line">            dfs(node -&gt; left);</span><br><span class="line">        ans.push_back(node -&gt; val);</span><br><span class="line">        <span class="keyword">if</span>(node -&gt; right != <span class="literal">nullptr</span>)</span><br><span class="line">            dfs(node -&gt; right); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode#637</title>
    <url>/2020/09/12/Leetcode-637/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="Leetcode-637二叉树的层平均值"><a href="#Leetcode-637二叉树的层平均值" class="headerlink" title="Leetcode#637二叉树的层平均值"></a>Leetcode#637二叉树的层平均值</h2><a id="more"></a>
<p>水题，直接一个裸的广搜，按层遍历树的每一层即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="built_in">queue</span>&lt;TreeNode*&gt;qu;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;ans;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">averageOfLevels</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        qu.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!qu.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> cnt = qu.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">double</span> temp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; cnt ;i ++)</span><br><span class="line">            &#123;</span><br><span class="line">                temp += qu.front() -&gt; val;</span><br><span class="line">                <span class="keyword">if</span>(qu.front() -&gt; left != <span class="literal">NULL</span>)</span><br><span class="line">                    qu.push(qu.front() -&gt; left);</span><br><span class="line">                <span class="keyword">if</span>(qu.front() -&gt; right != <span class="literal">NULL</span>)</span><br><span class="line">                    qu.push(qu.front() -&gt; right);</span><br><span class="line">                qu.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(temp/cnt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><del>尝试用auto声明居然出现了误差，不知道为什么会自动成int类型，果然还是菜啊</del></p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>c++模板</title>
    <url>/2020/10/21/c-%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>模板是一个c++中很神奇的结构，合理使用模板可以大大减少代码量以及提高代码复用性，接下来记录一下模板的学习笔记。</p>
<a id="more"></a>
<h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2><p>模板的基础使用很简单，而本质上当我们调用模板的时候不是直接调用了函数的模板，而是编译器通过模板生成了一个新的函数，直接上使用模板的绝对值的例子代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;//不使用<span class="title">class</span>关键字也可以使用<span class="title">typename</span>关键字<span class="title">template</span> &lt;typename T&gt;，也叫模板参数表</span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">abs</span>(<span class="title">T</span> <span class="title">a</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">return</span> a&gt;<span class="number">0</span>?a:-a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这其中有class/typename为函数的类型参数，T我的理解是相当于传递的函数形参。模板的基础中还有一个需要注意的点：只有能够进行函数中运算的类型，才能作为类型的参数，如果传递的类型参数为自定义类型，或者默认的运算符无法对它们进行操作，则需要我们先重载运算符再使用模板。</p>
<h2 id="类的模板"><a href="#类的模板" class="headerlink" title="类的模板"></a>类的模板</h2><p>和函数的模板差不多，类的模板也是通过使用模板生成一个我们需要的数据类型的类，比如我们可以这么写：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="comment">//T叫什么都行</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        T num;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function">T <span class="title">getnum</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T Base&lt;T&gt;::getnum()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在每一处使用需要使用模板对象的时候，都应该加上template<typename T>，其他和函数模板基本一样。</p>
<h2 id="数组模板"><a href="#数组模板" class="headerlink" title="数组模板"></a>数组模板</h2><p>在我们使用数组的时候，必须事先定义好数组的大小，这个大小是在编译的时候已经固定的，不能在运行的时候调整数组的大小。而在很多情况下，我们希望我们的数组可以动态的调整大小，在我们需要它储存更多数据时，进行动态的扩容（类似于stl中的vector），而数组模板就可以实现这个目的。<br>先看个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Array</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        T* <span class="built_in">list</span>;<span class="comment">//用于储存数组的首地址</span></span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">size</span>;<span class="comment">//动态数组的大小</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Array(<span class="keyword">int</span> sz = <span class="number">10</span>);<span class="comment">//构造函数</span></span><br><span class="line">        &#123;</span><br><span class="line">            assert(sz&gt;=<span class="number">0</span>)<span class="comment">//sz为数组大小</span></span><br><span class="line">            <span class="built_in">size</span> = sz;</span><br><span class="line">            <span class="built_in">list</span> = <span class="keyword">new</span> T[<span class="built_in">size</span>];<span class="comment">//动态分配size个T类型的空间</span></span><br><span class="line">        &#125;</span><br><span class="line">        Array(<span class="keyword">const</span> Array&lt;T&gt;&amp;a)<span class="comment">//复制构造函数，用于复制数组</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">size</span> = a.<span class="built_in">size</span> <span class="comment">//复制前一个对象的数组大小</span></span><br><span class="line">            <span class="built_in">list</span> = <span class="keyword">new</span> T[<span class="built_in">size</span>];<span class="comment">//动态分配size个T类型的大小</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="built_in">size</span> ; i++)<span class="comment">//将前一个对象的所有元素复制过来</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">list</span>[i] = a.<span class="built_in">list</span>[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ~Array();<span class="comment">//析构函数</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> [] <span class="built_in">list</span>;<span class="comment">//释放空间</span></span><br><span class="line">        &#125;</span><br><span class="line">        Array&lt;T&gt; &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Array&lt;T&gt; &amp;rhs)<span class="comment">//重载=</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(rhs != <span class="keyword">this</span>)<span class="comment">//如果两个对象不相等的话</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">delete</span> [] <span class="built_in">list</span>;<span class="comment">//删除原数组，并复制新数组</span></span><br><span class="line">                <span class="built_in">size</span> = rhs.<span class="built_in">size</span>();</span><br><span class="line">                <span class="built_in">list</span> = <span class="keyword">new</span> <span class="built_in">list</span>[<span class="built_in">size</span>];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="built_in">size</span> ; i++)</span><br><span class="line">                    <span class="built_in">list</span>[i] = rhs.<span class="built_in">list</span>[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;<span class="comment">//最后返回当前对象的引用</span></span><br><span class="line">        &#125;</span><br><span class="line">        T &amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> i)<span class="comment">//重载[]以便可以直接访问</span></span><br><span class="line">        &#123;</span><br><span class="line">            assert(i&gt;=<span class="number">0</span>&amp;&amp;i&lt;<span class="built_in">size</span>);<span class="comment">//检查数组是否越界</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">list</span>[i];<span class="comment">//返回下标为n的元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> T &amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> i) <span class="keyword">const</span><span class="comment">//与上同，只不过这次返回的是常量类型的元素</span></span><br><span class="line">        &#123;</span><br><span class="line">            assert(i&gt;=<span class="number">0</span>&amp;&amp;i&lt;<span class="built_in">size</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">list</span>[n];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">operator</span> T *()<span class="comment">//返回数组的指针</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">list</span>;<span class="comment">//返回对象中私有数组的首地址</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">operator</span> <span class="keyword">const</span> T*() <span class="keyword">const</span><span class="comment">//返回静态指针</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>Q1：为什么有的函数返回值为引用类型（运算符重载函数）？<br>W：因为重载的=，我们想要的效果是将这个值作为函数表达式中的左值，即可以直接操作，而如果不是引用类型，它只能做右值。（引用是对象的别名，所以可以通过引用修改对象的值）</li>
<li>Q2：为什么有的函数必须添加一个const类型？</li>
<li>W：比如指针，如果返回的是常指针，则我们只能通过这个指针读取动态数组中的元素，而不能通过这个指针对数组中的元素进行修改<br>这样就基本实现了一个<del>不</del>类似于vector的动态数组（当然vector要比这个简单的例子复杂很多了，毕竟正经的stl）模板是个很好用的c++特性，利用模板我们可以大大减少代码的重复量，增强代码的复用性（很多头文件中的函数的实现都是依赖于模板）</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title>OJ内核新坑</title>
    <url>/2020/10/07/OJ%E5%86%85%E6%A0%B8%E6%96%B0%E5%9D%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>最近准备写一个oj的内核以提升自己对于c++网络编程的理解和认识<del>（菜</del>，顺便没准还能投入实际生产使用环境中<del>（在想peach</del>。<br>今天先记录一下关于调用子进程的一些代码：</p>
<h2 id="system"><a href="#system" class="headerlink" title="system()"></a>system()</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line">system();</span><br></pre></td></tr></table></figure>
<p>system函数大家应该都用过吧，它的功能就是在终端中发出一个命令，也就是相当于直接在c文件中实现在终端的命令运行。<br>system的实质其实和exec类似，system（）和exec（）都可以执行进程外的命令，system是在原进程上开辟了一个新的进程，但是exec是用新进程（命令）覆盖了原有的进程；而system（）和exec（）都有能产生返回值，system的返回值并不影响原有进程，但是exec的返回值影响了原进程。<br>但是</p>
]]></content>
      <categories>
        <category>OJ内核</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>oj内核</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql远程连接</title>
    <url>/2020/07/14/mysql%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>今天记录一个困扰了我很久，每次都是莫名其妙发生又莫名其妙解决的问题：当使用navicat连接远程数据库时无法连接（错误代码2003或其他）问题的简单分析和解决方案。</p>
<a id="more"></a>
<p>当远程连接mysql数据库连接失败时，一般分为几种情况：</p>
<ul>
<li>未授予远程账号使用root连接的权限</li>
<li>在配置文件中限定了只有本地IP可以连接</li>
<li>Linux系统防火墙对3306端口（或其他指定端口）进行了限制<h2 id="授予远程账号访问权限"><a href="#授予远程账号访问权限" class="headerlink" title="授予远程账号访问权限"></a>授予远程账号访问权限</h2>在终端登陆mysql，选择mysql数据库之后查询user表中的host信息<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; use mysql;</span><br><span class="line">Database changed</span><br><span class="line">mysql&gt; select user,password,host from user;</span><br><span class="line">+------+-------------------------------------------+----------------+</span><br><span class="line">| user | password                                  | host           |</span><br><span class="line">+------+-------------------------------------------+----------------+</span><br><span class="line">| root | *81F5E21E35407D884A6CD4A731AEBFB6AF209E1B | localhost      |</span><br><span class="line">| root | *81F5E21E35407D884A6CD4A731AEBFB6AF209E1B | 127.0.0.1      |</span><br><span class="line">| root | *81F5E21E35407D884A6CD4A731AEBFB6AF209E1B | ::1            |</span><br><span class="line">+------+-------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>
可以看到当用户为root时，只有本地账户可以进行连接，我们只需要把localhost修改为%即可。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">update user set host&#x3D;&quot;%&quot; where host&#x3D;&quot;localhost&quot;;</span><br></pre></td></tr></table></figure>
<h2 id="解除配置文件只允许本地连接的限制"><a href="#解除配置文件只允许本地连接的限制" class="headerlink" title="解除配置文件只允许本地连接的限制"></a>解除配置文件只允许本地连接的限制</h2>找到my.conf(一般在/etc/my.conf或/etc/mysql/my.conf，版本不同会造成差异)，将下面的代码注释掉。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bind-address &#x3D; 127.0.0.1</span><br></pre></td></tr></table></figure>
<h2 id="解除linux对端口的限制"><a href="#解除linux对端口的限制" class="headerlink" title="解除linux对端口的限制"></a>解除linux对端口的限制</h2>前面两个问题其实大部分时候都会注意到，这最后一个可真是困扰了我好久<br><del>（菜）</del>。</li>
</ul>
<p>首先是iptables，经过查阅资料我发现tables本身就是linux内核的一部分所以无法删除<br><del>（我还天真的想把它删了）</del><br>所以我们要做的是直接解除iptables对所有端口的限制：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables -P INPUT ACCEPT</span><br><span class="line">iptables -P OUTPUT ACCEPT</span><br><span class="line">iptables -P FORWARD ACCEPT</span><br><span class="line">iptables -F</span><br></pre></td></tr></table></figure>
<p>然后如果开启了ufw，也需要关闭：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo ufw disable</span><br></pre></td></tr></table></figure>

<p>最后不要忘记重启MySQL服务。</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>Navicat</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#24</title>
    <url>/2020/10/13/LeetCode-24/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="LeetCode-24两两交换链表中的节点"><a href="#LeetCode-24两两交换链表中的节点" class="headerlink" title="LeetCode#24两两交换链表中的节点"></a>LeetCode#24两两交换链表中的节点</h2><a id="more"></a>
<p><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/" target="_blank" rel="noopener">题目链接</a><br>题面很简单，将所有节点两两交换，我先想到的是使用循环的方式，但是题解给出了更简单的递归写法。使用递归的好处是可以不用考虑两节点交换后后面那个节点的next节点应该连接到哪个节点（如果遍历的话，每次交换的两个节点的后节点的next指针将很难处理，因为后节点也需要进行交换）<br>附代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || head -&gt; next == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* node = head -&gt; next;</span><br><span class="line">        head -&gt; next = swapPairs(node -&gt; next);</span><br><span class="line">        node -&gt; next = head;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo-next主题的美化</title>
    <url>/2020/07/08/hexo-next%E4%B8%BB%E9%A2%98%E7%9A%84%E7%BE%8E%E5%8C%96/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>博客已经基本能用了，剩下就是一些强迫症的美化工作了，next主题默认的是极简的黑白风配色，官方并没有提供相对应的接口进行颜色的修改，参考了<a href="https://zhouhuix.cn/2016/11/24/%E4%BF%AE%E6%94%B9Hexo%E7%9A%84Next%E4%B8%BB%E9%A2%98/" target="_blank" rel="noopener">大佬的一篇博客</a>以及另一篇<a href="https://www.jianshu.com/p/2a8d399f1266" target="_blank" rel="noopener">大佬的自定义内容</a>，对配色进行了简单的修改，然后就是点击效果的修改和其他亿些细节的修改。</p>
<a id="more"></a>
<h1 id="修改配色"><a href="#修改配色" class="headerlink" title="修改配色"></a>修改配色</h1><p>打开hexo/themes/next/source/css/_variables/base.styl，找到如下内容：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">$whitesmoke   = #f5f5f5;</span><br><span class="line">$gainsboro    = #eee;</span><br><span class="line">$grey-lighter = #ddd;</span><br><span class="line">$grey-light   = #ccc;</span><br><span class="line">$grey         = #bbb;</span><br><span class="line">$grey-dark    = #999;</span><br><span class="line">$grey-dim     = #666;</span><br><span class="line">$black-light  = #555;</span><br><span class="line">$black-dim    = #333;</span><br><span class="line">$black-deep   = #70b7fd;//这是我们需要修改的，默认为#555</span><br><span class="line">$red          = #ff2a2a;</span><br><span class="line">$blue-bright  = #87daff;</span><br><span class="line">$blue         = #0684bd;</span><br><span class="line">$custom_blue  = #70b7fd;//这是我自己添加的，可以不加</span><br><span class="line">$blue-deep    = #262a30;</span><br><span class="line">$orange       = #fc6423;</span><br></pre></td></tr></table></figure>
<p>其实这并不是最优的解法，因为这其实是全局替换了一个颜色，所有用到这个颜色的都会被替换成修改过的颜色（然而我并没有搞明白具体在哪单独修改，如果有大佬可以指导我一下就太好了，<del>这个大坑等以后来填</del>）</p>
<p>为了让效果更好，我们还要再额外添加一些自定义内容，但根据第二篇大佬的博客，custom文件夹已经不见了，在评论区我找到了新版本的解法：</p>
<ul>
<li>首先在next主题的config文件中将style取消注释，这样就可以开启自定义的样式了<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">custom_file_path:</span></span><br><span class="line">  <span class="comment">#head: source/_data/head.swig</span></span><br><span class="line">  <span class="comment">#header: source/_data/header.swig</span></span><br><span class="line">  <span class="comment">#sidebar: source/_data/sidebar.swig</span></span><br><span class="line">  <span class="comment">#postMeta: source/_data/post-meta.swig</span></span><br><span class="line">  <span class="comment">#postBodyEnd: source/_data/post-body-end.swig</span></span><br><span class="line">  <span class="attr">footer:</span> <span class="string">source/_data/footer.swig</span></span><br><span class="line">  <span class="comment">#bodyEnd: source/_data/body-end.swig</span></span><br><span class="line">  <span class="comment">#variable: source/_data/variables.styl</span></span><br><span class="line">  <span class="comment">#mixin: source/_data/mixins.styl</span></span><br><span class="line">  <span class="attr">style:</span> <span class="string">source/_data/styles.styl</span></span><br></pre></td></tr></table></figure>
在/source中新建_data文件夹，再新建styles.styl文件（其实其他位置其他文件名也没问题，但是需要在上面进行修改），再在styles文件里加入如下代码：<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">// 修改网站头部颜色</span><br><span class="line"><span class="selector-class">.headband</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">3px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#70b7fd</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.site-meta</span> &#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">20px</span> <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#70b7fd</span>;</span><br><span class="line">&#125;</span><br><span class="line">//这个似乎没啥用...</span><br><span class="line"><span class="selector-class">.site-subtitle</span> &#123;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">13px</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#ffffff</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 修改按键（button）样式</span><br><span class="line"><span class="selector-class">.btn</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#70b7fd</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">2px</span> solid <span class="number">#70b7fd</span>;</span><br><span class="line">&#125;</span><br><span class="line">// 按键（button）点击时样式</span><br><span class="line"><span class="selector-class">.btn</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">border-color</span>: <span class="number">#70b7fd</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#70b7fd</span>;</span><br><span class="line">&#125;</span><br><span class="line">// 鼠标移动至文章标题时的效果</span><br><span class="line"><span class="selector-class">.posts-expand</span> <span class="selector-class">.post-title-link</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">2px</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#70b7fd</span>;</span><br><span class="line">    <span class="attribute">visibility</span>: hidden;</span><br><span class="line">    <span class="attribute">-webkit-transform</span>: <span class="built_in">scaleX</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="attribute">-moz-transform</span>: <span class="built_in">scaleX</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="attribute">-ms-transform</span>: <span class="built_in">scaleX</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="attribute">-o-transform</span>: <span class="built_in">scaleX</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scaleX</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="attribute">transition-duration</span>: <span class="number">0.2s</span>;</span><br><span class="line">    <span class="attribute">transition-timing-function</span>: ease-in-out;</span><br><span class="line">    <span class="attribute">transition-delay</span>: <span class="number">0s</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
效果如图：<br><img src="/images/7.png" alt=""></li>
</ul>
<h1 id="修改点击效果"><a href="#修改点击效果" class="headerlink" title="修改点击效果"></a>修改点击效果</h1><p>参考自<a href="https://hasaik.com/posts/9c9b482b.html" target="_blank" rel="noopener">博客</a><br>首先在/themes/next/_config.yml添加选项：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">cursor_effect:</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">explosion</span>  <span class="comment">#explosion：爆炸 | love：浮出爱心 需要什么效果自己选</span></span><br></pre></td></tr></table></figure>
<p>在/themes/next/layout/_custom/custom.swig ，添加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% if theme.cursor_effect %&#125;</span><br><span class="line">  &#123;% if theme.cursor_effect.type &#x3D;&#x3D; &quot;fireworks&quot; %&#125;</span><br><span class="line">    &lt;script src&#x3D;&quot;&#x2F;js&#x2F;cursor&#x2F;fireworks.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">  &#123;% elseif theme.cursor_effect.type &#x3D;&#x3D; &quot;explosion&quot; %&#125;</span><br><span class="line">    &lt;canvas class&#x3D;&quot;fireworks&quot; style&#x3D;&quot;position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;&quot; &gt;&lt;&#x2F;canvas&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;&#x2F;&#x2F;cdn.bootcss.com&#x2F;animejs&#x2F;2.2.0&#x2F;anime.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;&#x2F;js&#x2F;cursor&#x2F;explosion.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">  &#123;% elseif theme.cursor_effect.type &#x3D;&#x3D; &quot;love&quot; %&#125;</span><br><span class="line">    &lt;script src&#x3D;&quot;&#x2F;js&#x2F;cursor&#x2F;love.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">  &#123;% elseif theme.cursor_effect.type &#x3D;&#x3D; &quot;text&quot; %&#125;</span><br><span class="line">    &lt;script src&#x3D;&quot;&#x2F;js&#x2F;cursor&#x2F;text.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<p>如果没有这个文件夹和文件需要自己手动创建，同时在 /themes/next/layout/_layout.swig 中引入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% include &#39;_custom&#x2F;custom.swig&#39; %&#125;</span><br></pre></td></tr></table></figure>
<p>然后将这两个js文件复制到/themes/next/source/js/cursor/（没有的话手动创建）</p>
<p>explosion.min.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;<span class="function"><span class="keyword">function</span> <span class="title">updateCoords</span>(<span class="params">e</span>)</span>&#123;pointerX=(e.clientX||e.touches[<span class="number">0</span>].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[<span class="number">0</span>].clientY-canvasEl.getBoundingClientRect().top&#125;<span class="function"><span class="keyword">function</span> <span class="title">setParticuleDirection</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">var</span> t=anime.random(<span class="number">0</span>,<span class="number">360</span>)*<span class="built_in">Math</span>.PI/<span class="number">180</span>,a=anime.random(<span class="number">50</span>,<span class="number">180</span>),n=[<span class="number">-1</span>,<span class="number">1</span>][anime.random(<span class="number">0</span>,<span class="number">1</span>)]*a;<span class="keyword">return</span>&#123;<span class="attr">x</span>:e.x+n*<span class="built_in">Math</span>.cos(t),<span class="attr">y</span>:e.y+n*<span class="built_in">Math</span>.sin(t)&#125;&#125;<span class="function"><span class="keyword">function</span> <span class="title">createParticule</span>(<span class="params">e,t</span>)</span>&#123;<span class="keyword">var</span> a=&#123;&#125;;<span class="keyword">return</span> a.x=e,a.y=t,a.color=colors[anime.random(<span class="number">0</span>,colors.length<span class="number">-1</span>)],a.radius=anime.random(<span class="number">16</span>,<span class="number">32</span>),a.endPos=setParticuleDirection(a),a.draw=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">Math</span>.PI,!<span class="number">0</span>),ctx.fillStyle=a.color,ctx.fill()&#125;,a&#125;<span class="function"><span class="keyword">function</span> <span class="title">createCircle</span>(<span class="params">e,t</span>)</span>&#123;<span class="keyword">var</span> a=&#123;&#125;;<span class="keyword">return</span> a.x=e,a.y=t,a.color=<span class="string">"#F00"</span>,a.radius=<span class="number">0.1</span>,a.alpha=<span class="number">0.5</span>,a.lineWidth=<span class="number">6</span>,a.draw=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">Math</span>.PI,!<span class="number">0</span>),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=<span class="number">1</span>&#125;,a&#125;<span class="function"><span class="keyword">function</span> <span class="title">renderParticule</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">for</span>(<span class="keyword">var</span> t=<span class="number">0</span>;t&lt;e.animatables.length;t++)&#123;e.animatables[t].target.draw()&#125;&#125;<span class="function"><span class="keyword">function</span> <span class="title">animateParticules</span>(<span class="params">e,t</span>)</span>&#123;<span class="keyword">for</span>(<span class="keyword">var</span> a=createCircle(e,t),n=[],i=<span class="number">0</span>;i&lt;numberOfParticules;i++)&#123;n.push(createParticule(e,t))&#125;anime.timeline().add(&#123;<span class="attr">targets</span>:n,<span class="attr">x</span>:<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">return</span> e.endPos.x&#125;,<span class="attr">y</span>:<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">return</span> e.endPos.y&#125;,<span class="attr">radius</span>:<span class="number">0.1</span>,<span class="attr">duration</span>:anime.random(<span class="number">1200</span>,<span class="number">1800</span>),<span class="attr">easing</span>:<span class="string">"easeOutExpo"</span>,<span class="attr">update</span>:renderParticule&#125;).add(&#123;<span class="attr">targets</span>:a,<span class="attr">radius</span>:anime.random(<span class="number">80</span>,<span class="number">160</span>),<span class="attr">lineWidth</span>:<span class="number">0</span>,<span class="attr">alpha</span>:&#123;<span class="attr">value</span>:<span class="number">0</span>,<span class="attr">easing</span>:<span class="string">"linear"</span>,<span class="attr">duration</span>:anime.random(<span class="number">600</span>,<span class="number">800</span>)&#125;,<span class="attr">duration</span>:anime.random(<span class="number">1200</span>,<span class="number">1800</span>),<span class="attr">easing</span>:<span class="string">"easeOutExpo"</span>,<span class="attr">update</span>:renderParticule,<span class="attr">offset</span>:<span class="number">0</span>&#125;)&#125;<span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">e,t</span>)</span>&#123;<span class="keyword">var</span> a;<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">var</span> n=<span class="keyword">this</span>,i=<span class="built_in">arguments</span>;clearTimeout(a),a=setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;e.apply(n,i)&#125;,t)&#125;&#125;<span class="keyword">var</span> canvasEl=<span class="built_in">document</span>.querySelector(<span class="string">".fireworks"</span>);<span class="keyword">if</span>(canvasEl)&#123;<span class="keyword">var</span> ctx=canvasEl.getContext(<span class="string">"2d"</span>),numberOfParticules=<span class="number">30</span>,pointerX=<span class="number">0</span>,pointerY=<span class="number">0</span>,tap=<span class="string">"mousedown"</span>,colors=[<span class="string">"#FF1461"</span>,<span class="string">"#18FF92"</span>,<span class="string">"#5A87FF"</span>,<span class="string">"#FBF38C"</span>],setCanvasSize=debounce(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;canvasEl.width=<span class="number">2</span>*<span class="built_in">window</span>.innerWidth,canvasEl.height=<span class="number">2</span>*<span class="built_in">window</span>.innerHeight,canvasEl.style.width=<span class="built_in">window</span>.innerWidth+<span class="string">"px"</span>,canvasEl.style.height=<span class="built_in">window</span>.innerHeight+<span class="string">"px"</span>,canvasEl.getContext(<span class="string">"2d"</span>).scale(<span class="number">2</span>,<span class="number">2</span>)&#125;,<span class="number">500</span>),render=anime(&#123;<span class="attr">duration</span>:<span class="number">1</span>/<span class="number">0</span>,<span class="attr">update</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;ctx.clearRect(<span class="number">0</span>,<span class="number">0</span>,canvasEl.width,canvasEl.height)&#125;&#125;);<span class="built_in">document</span>.addEventListener(tap,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;<span class="string">"sidebar"</span>!==e.target.id&amp;&amp;<span class="string">"toggle-sidebar"</span>!==e.target.id&amp;&amp;<span class="string">"A"</span>!==e.target.nodeName&amp;&amp;<span class="string">"IMG"</span>!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))&#125;,!<span class="number">1</span>),setCanvasSize(),<span class="built_in">window</span>.addEventListener(<span class="string">"resize"</span>,setCanvasSize,!<span class="number">1</span>)&#125;<span class="string">"use strict"</span>;<span class="function"><span class="keyword">function</span> <span class="title">updateCoords</span>(<span class="params">e</span>)</span>&#123;pointerX=(e.clientX||e.touches[<span class="number">0</span>].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[<span class="number">0</span>].clientY-canvasEl.getBoundingClientRect().top&#125;<span class="function"><span class="keyword">function</span> <span class="title">setParticuleDirection</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">var</span> t=anime.random(<span class="number">0</span>,<span class="number">360</span>)*<span class="built_in">Math</span>.PI/<span class="number">180</span>,a=anime.random(<span class="number">50</span>,<span class="number">180</span>),n=[<span class="number">-1</span>,<span class="number">1</span>][anime.random(<span class="number">0</span>,<span class="number">1</span>)]*a;<span class="keyword">return</span>&#123;<span class="attr">x</span>:e.x+n*<span class="built_in">Math</span>.cos(t),<span class="attr">y</span>:e.y+n*<span class="built_in">Math</span>.sin(t)&#125;&#125;<span class="function"><span class="keyword">function</span> <span class="title">createParticule</span>(<span class="params">e,t</span>)</span>&#123;<span class="keyword">var</span> a=&#123;&#125;;<span class="keyword">return</span> a.x=e,a.y=t,a.color=colors[anime.random(<span class="number">0</span>,colors.length<span class="number">-1</span>)],a.radius=anime.random(<span class="number">16</span>,<span class="number">32</span>),a.endPos=setParticuleDirection(a),a.draw=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">Math</span>.PI,!<span class="number">0</span>),ctx.fillStyle=a.color,ctx.fill()&#125;,a&#125;<span class="function"><span class="keyword">function</span> <span class="title">createCircle</span>(<span class="params">e,t</span>)</span>&#123;<span class="keyword">var</span> a=&#123;&#125;;<span class="keyword">return</span> a.x=e,a.y=t,a.color=<span class="string">"#F00"</span>,a.radius=<span class="number">0.1</span>,a.alpha=<span class="number">0.5</span>,a.lineWidth=<span class="number">6</span>,a.draw=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">Math</span>.PI,!<span class="number">0</span>),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=<span class="number">1</span>&#125;,a&#125;<span class="function"><span class="keyword">function</span> <span class="title">renderParticule</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">for</span>(<span class="keyword">var</span> t=<span class="number">0</span>;t&lt;e.animatables.length;t++)&#123;e.animatables[t].target.draw()&#125;&#125;<span class="function"><span class="keyword">function</span> <span class="title">animateParticules</span>(<span class="params">e,t</span>)</span>&#123;<span class="keyword">for</span>(<span class="keyword">var</span> a=createCircle(e,t),n=[],i=<span class="number">0</span>;i&lt;numberOfParticules;i++)&#123;n.push(createParticule(e,t))&#125;anime.timeline().add(&#123;<span class="attr">targets</span>:n,<span class="attr">x</span>:<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">return</span> e.endPos.x&#125;,<span class="attr">y</span>:<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">return</span> e.endPos.y&#125;,<span class="attr">radius</span>:<span class="number">0.1</span>,<span class="attr">duration</span>:anime.random(<span class="number">1200</span>,<span class="number">1800</span>),<span class="attr">easing</span>:<span class="string">"easeOutExpo"</span>,<span class="attr">update</span>:renderParticule&#125;).add(&#123;<span class="attr">targets</span>:a,<span class="attr">radius</span>:anime.random(<span class="number">80</span>,<span class="number">160</span>),<span class="attr">lineWidth</span>:<span class="number">0</span>,<span class="attr">alpha</span>:&#123;<span class="attr">value</span>:<span class="number">0</span>,<span class="attr">easing</span>:<span class="string">"linear"</span>,<span class="attr">duration</span>:anime.random(<span class="number">600</span>,<span class="number">800</span>)&#125;,<span class="attr">duration</span>:anime.random(<span class="number">1200</span>,<span class="number">1800</span>),<span class="attr">easing</span>:<span class="string">"easeOutExpo"</span>,<span class="attr">update</span>:renderParticule,<span class="attr">offset</span>:<span class="number">0</span>&#125;)&#125;<span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">e,t</span>)</span>&#123;<span class="keyword">var</span> a;<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">var</span> n=<span class="keyword">this</span>,i=<span class="built_in">arguments</span>;clearTimeout(a),a=setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;e.apply(n,i)&#125;,t)&#125;&#125;<span class="keyword">var</span> canvasEl=<span class="built_in">document</span>.querySelector(<span class="string">".fireworks"</span>);<span class="keyword">if</span>(canvasEl)&#123;<span class="keyword">var</span> ctx=canvasEl.getContext(<span class="string">"2d"</span>),numberOfParticules=<span class="number">30</span>,pointerX=<span class="number">0</span>,pointerY=<span class="number">0</span>,tap=<span class="string">"mousedown"</span>,colors=[<span class="string">"#FF1461"</span>,<span class="string">"#18FF92"</span>,<span class="string">"#5A87FF"</span>,<span class="string">"#FBF38C"</span>],setCanvasSize=debounce(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;canvasEl.width=<span class="number">2</span>*<span class="built_in">window</span>.innerWidth,canvasEl.height=<span class="number">2</span>*<span class="built_in">window</span>.innerHeight,canvasEl.style.width=<span class="built_in">window</span>.innerWidth+<span class="string">"px"</span>,canvasEl.style.height=<span class="built_in">window</span>.innerHeight+<span class="string">"px"</span>,canvasEl.getContext(<span class="string">"2d"</span>).scale(<span class="number">2</span>,<span class="number">2</span>)&#125;,<span class="number">500</span>),render=anime(&#123;<span class="attr">duration</span>:<span class="number">1</span>/<span class="number">0</span>,<span class="attr">update</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;ctx.clearRect(<span class="number">0</span>,<span class="number">0</span>,canvasEl.width,canvasEl.height)&#125;&#125;);<span class="built_in">document</span>.addEventListener(tap,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;<span class="string">"sidebar"</span>!==e.target.id&amp;&amp;<span class="string">"toggle-sidebar"</span>!==e.target.id&amp;&amp;<span class="string">"A"</span>!==e.target.nodeName&amp;&amp;<span class="string">"IMG"</span>!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))&#125;,!<span class="number">1</span>),setCanvasSize(),<span class="built_in">window</span>.addEventListener(<span class="string">"resize"</span>,setCanvasSize,!<span class="number">1</span>)&#125;;</span><br></pre></td></tr></table></figure>

<p>love.min.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params">e,t,a</span>)</span>&#123;<span class="function"><span class="keyword">function</span> <span class="title">n</span>(<span class="params"></span>)</span>&#123;c(<span class="string">".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;"</span>),o(),r()&#125;<span class="function"><span class="keyword">function</span> <span class="title">r</span>(<span class="params"></span>)</span>&#123;<span class="keyword">for</span>(<span class="keyword">var</span> e=<span class="number">0</span>;e&lt;d.length;e++)d[e].alpha&lt;=<span class="number">0</span>?(t.body.removeChild(d[e].el),d.splice(e,<span class="number">1</span>)):(d[e].y--,d[e].scale+=<span class="number">.004</span>,d[e].alpha-=<span class="number">.013</span>,d[e].el.style.cssText=<span class="string">"left:"</span>+d[e].x+<span class="string">"px;top:"</span>+d[e].y+<span class="string">"px;opacity:"</span>+d[e].alpha+<span class="string">";transform:scale("</span>+d[e].scale+<span class="string">","</span>+d[e].scale+<span class="string">") rotate(45deg);background:"</span>+d[e].color+<span class="string">";z-index:99999"</span>);requestAnimationFrame(r)&#125;<span class="function"><span class="keyword">function</span> <span class="title">o</span>(<span class="params"></span>)</span>&#123;<span class="keyword">var</span> t=<span class="string">"function"</span>==<span class="keyword">typeof</span> e.onclick&amp;&amp;e.onclick;e.onclick=<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;t&amp;&amp;t(),i(e)&#125;&#125;<span class="function"><span class="keyword">function</span> <span class="title">i</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">var</span> a=t.createElement(<span class="string">"div"</span>);a.className=<span class="string">"heart"</span>,d.push(&#123;<span class="attr">el</span>:a,<span class="attr">x</span>:e.clientX<span class="number">-5</span>,<span class="attr">y</span>:e.clientY<span class="number">-5</span>,<span class="attr">scale</span>:<span class="number">1</span>,<span class="attr">alpha</span>:<span class="number">1</span>,<span class="attr">color</span>:s()&#125;),t.body.appendChild(a)&#125;<span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">var</span> a=t.createElement(<span class="string">"style"</span>);a.type=<span class="string">"text/css"</span>;<span class="keyword">try</span>&#123;a.appendChild(t.createTextNode(e))&#125;<span class="keyword">catch</span>(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName(<span class="string">"head"</span>)[<span class="number">0</span>].appendChild(a)&#125;<span class="function"><span class="keyword">function</span> <span class="title">s</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span><span class="string">"rgb("</span>+~~(<span class="number">255</span>*<span class="built_in">Math</span>.random())+<span class="string">","</span>+~~(<span class="number">255</span>*<span class="built_in">Math</span>.random())+<span class="string">","</span>+~~(<span class="number">255</span>*<span class="built_in">Math</span>.random())+<span class="string">")"</span>&#125;<span class="keyword">var</span> d=[];e.requestAnimationFrame=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;setTimeout(e,<span class="number">1e3</span>/<span class="number">60</span>)&#125;&#125;(),n()&#125;(<span class="built_in">window</span>,<span class="built_in">document</span>);</span><br></pre></td></tr></table></figure>
<p>保存编译即可，enjoy it~</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>美化</tag>
        <tag>hexo</tag>
        <tag>点击效果</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode#538</title>
    <url>/2020/09/21/Leetcode-538/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="Leetcode-538把二叉搜索树转换为累加树"><a href="#Leetcode-538把二叉搜索树转换为累加树" class="headerlink" title="Leetcode#538把二叉搜索树转换为累加树"></a>Leetcode#538把二叉搜索树转换为累加树</h2><a id="more"></a>
<p><a href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/" target="_blank" rel="noopener">题目链接</a><br>刚开始看题的时候没有注意是二叉搜索树，所以只想到了用最傻x的方法：先将整个二叉树遍历一遍，取得所有val然后进行排序，再遍历二叉树分别，配合已经排序好的val数组进行循环累加。这样也是可以过的，但是不管时间复杂度还是空间复杂度都很高。<br>附一个不需要注释就能看懂的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* node,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        nums.push_back(node -&gt; val);</span><br><span class="line">        <span class="keyword">if</span>(node -&gt; left != <span class="literal">nullptr</span>)</span><br><span class="line">            dfs(node -&gt; left,nums);</span><br><span class="line">        <span class="keyword">if</span>(node -&gt; right != <span class="literal">nullptr</span>)</span><br><span class="line">           dfs(node -&gt; right,nums);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(TreeNode* node,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.<span class="built_in">size</span>() ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( nums[i] &gt; node -&gt; val)</span><br><span class="line">                sum+=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        node -&gt; val += sum;</span><br><span class="line">        <span class="keyword">if</span>(node -&gt; left != <span class="literal">nullptr</span>)</span><br><span class="line">            dfs1(node -&gt; left,nums);</span><br><span class="line">        <span class="keyword">if</span>(node -&gt; right != <span class="literal">nullptr</span>)</span><br><span class="line">           dfs1(node -&gt; right,nums);   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">convertBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;nums;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        dfs(root,nums);</span><br><span class="line">        sort(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        dfs1(root,nums);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>因为是二叉搜索树，所以已经排好了顺序，我们只需要通过反向中序遍历，就可以实现从大到小的累加和排序，只需要一遍就可以实现效果</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">convertBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            convertBST(root-&gt;right);</span><br><span class="line">            sum += root-&gt;val;</span><br><span class="line">            root-&gt;val = sum;</span><br><span class="line">            convertBST(root-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>为Windows安装SSH功能并上传GitHub</title>
    <url>/2020/10/04/%E4%B8%BAWindows%E5%AE%89%E8%A3%85SSH%E5%8A%9F%E8%83%BD%E5%B9%B6%E4%B8%8A%E4%BC%A0GitHub/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>ssh可以说是我们连接服务器的必备组件了，不同于Linux默认自带<del>并不</del>，windows好像并没有自带这个功能，下面记录一下在Windows下如何安装SSH并生成密钥上传到github上。</p>
<a id="more"></a>
<h2 id="最简单的方法"><a href="#最简单的方法" class="headerlink" title="最简单的方法"></a>最简单的方法</h2><p>说实话我是没有印象在我的windows上安装过openssh或者配置过环境变量链接ssh，但是我的环境变量中确实有System32文件夹下的open-ssh<del>其实就是系统自带的</del>，经过Google，我发现后序版本的win10其实是自带open-ssh客户端的，如果ssh命令失效我们只需要启用就可以了，具体步骤如下：<br><img src="/images/8.png" alt=""><br><img src="/images/9.png" alt=""><br>然后在添加功能中选择open-ssh即可</p>
<h2 id="手动安装open-ssh客户端"><a href="#手动安装open-ssh客户端" class="headerlink" title="手动安装open-ssh客户端"></a>手动安装open-ssh客户端</h2><ul>
<li>首先下载<a href="https://github.com/PowerShell/Win32-OpenSSH/releases" target="_blank" rel="noopener">最新的openssh</a></li>
<li>下载好后解压到任意地方</li>
<li>然后配置环境变量<br><img src="/images/10.png" alt=""><br><img src="/images/11.png" alt=""><br><img src="/images/12.png" alt=""></li>
<li>然后新建一个变量，位置填刚才解压openssh的位置<h2 id="生成GitHub密钥并上传"><a href="#生成GitHub密钥并上传" class="headerlink" title="生成GitHub密钥并上传"></a>生成GitHub密钥并上传</h2></li>
<li>在终端中输入：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen&#x2F;&#x2F;生成新的密钥</span><br></pre></td></tr></table></figure></li>
<li>一路回车即可，记住生成密钥的位置（一般为C:\Users\用户名.ssh）</li>
<li>然后登陆GitHub，在右上角找到setting<br><img src="/images/13.png" alt=""></li>
<li>点击new ssh key，将id_isa.pub中的内容全部复制进去即可<br>enjoy it~</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>ssh</tag>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>哈希表</title>
    <url>/2020/09/22/%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>在c++ STL中还有一种重要的数据结构，它虽然不在标准的stl库中，但是用途广泛速度奇快，这就是哈希表。</p>
<a id="more"></a>
<p><a href="https://blog.csdn.net/u010025211/article/details/46653519" target="_blank" rel="noopener">参考链接</a><br>哈希表和map类似，也是提供一个关键字和一个数据存储，并且一一对应，但是与map不同的是，map的底层实现是依靠<a href="/2020/09/15/%E7%BA%A2%E9%BB%91%E6%A0%91/" title="红黑树">红黑树</a>。</p>
<p>既然提到了红黑树，那就一定要把红黑树和哈希表进行一下对比：</p>
<ul>
<li>时间复杂度上，哈希表的速度要远超红黑树，尤其数据量越大越明显，哈希表为O(1)常数级，而红黑树为O(logn)，但是极端情况下哈希表可能会到O(n)，反而不如红黑树</li>
<li>空间复杂度上，红黑树为树形结构，数据存在每个节点中，而例如map只储存节点的指针关系，但是哈希表为先申请一大块内存，将每一个数据和key存入一个个桶中，所以如果对空间要求较高，优先使用红黑树</li>
<li>其他方面，以哈希表为底层结构的stl容器，在插入删除操作后，它所对应的迭代器不会发生变化（上一条中已经说过了，这些容器只是储存指针的位置，增删也只是调整指针，在内存中块内存并没有发生改变，所以迭代器继续有效），而哈希表是利用桶，每次插入需要加入一个新的桶，或将已存在的桶转移扩大，操作内存可能会导致迭代器失效。（如果对哈希表的其中一个桶进行erase（擦除操作），是将此桶对应的映射擦除，而不影响其他桶的迭代器。）</li>
</ul>
<p>在我的理解中，哈希表是类似vector/数组的一段连续的内存，所以可以通过直接访问“下标”的方式来访问我们需要的value（下标即为key值，但实际储存时为哈希值，下文会说），这样直接访问的方式当然要比平衡二叉树的查找要快得多。</p>
<p>在我们向哈希表中插入元素的时候，首先获取key值，然后通过哈希函数得到哈希值，再通过哈希值获得“桶号”，最后将key和value存入桶中；取出元素时则进行逆向操作，获取key，得到哈希值，得到桶号，比较key值是否相等，相等则得到对应的value，否则返回false。而只要是常见的内建数据类型，我们就可以直接使用自带的hash模板。<br>附c++ hash函数模板源码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hash</span>&lt;int&gt; &#123;</span></span><br><span class="line">        <span class="function"><span class="keyword">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> __x)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> __x; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hash</span>&lt;char*&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">hash</span>&lt;const char*&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">hash</span>&lt;char&gt; </span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">hash</span>&lt;unsigned char&gt; </span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">hash</span>&lt;signed char&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">hash</span>&lt;short&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">hash</span>&lt;unsigned short&gt; </span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">hash</span>&lt;int&gt; </span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">hash</span>&lt;unsigned int&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">hash</span>&lt;long&gt; </span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">hash</span>&lt;unsigned long&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>c++虚函数</title>
    <url>/2020/10/19/c-%E8%99%9A%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>今天复习<del>（学习）</del>了c++中的虚函数，在这里做一下记录。</p>
<a id="more"></a>
<h2 id="virtual函数的作用"><a href="#virtual函数的作用" class="headerlink" title="virtual函数的作用"></a>virtual函数的作用</h2><p>虚函数的作用是实现动态绑定，比如我们想定义一个函数，用这个函数实现对不同的类调用相同名的成员函数，首先想到的可能是这样写的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//假设我们已经声明了Base1、Base2、Derived三个类，Base2继承于Base1，Derived继承于Base2，它们中都有手动声明的print成员函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(Base1 *obj)</span><span class="comment">//此函数是想达成我们想要的效果，即使用此函数可以实现调用不同类中的print函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    obj -&gt; <span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为我们不知道我们要调用的是哪个类中的print，所以我们只能传递一个指针，来表示传递了一个对象</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Base1 a;</span><br><span class="line">Base2 b;</span><br><span class="line">Derived c;</span><br><span class="line"><span class="built_in">display</span>(&amp;a);</span><br><span class="line"><span class="built_in">display</span>(&amp;b);</span><br><span class="line"><span class="built_in">display</span>(&amp;c);</span><br></pre></td></tr></table></figure>
<p>看似没问题，但是这样的输出结果其实是调用了三遍a的print函数，因为在编译过程中，编译器无法根据指针去判断它指向什么类型的对象，所以display函数已经确定了对象是Base1类型的，他就只能调用这个类的print函数，这与我们要求的动态绑定不符。<br>如果能够推迟这个函数的表达式，让它到程序运行的时候才决定到底指针是什么类型的，那么是不是就达到了我们的要求呢？那我们又应该怎么做呢？答案就是使用virtual关键字。</p>
<h2 id="virtual函数的使用"><a href="#virtual函数的使用" class="headerlink" title="virtual函数的使用"></a>virtual函数的使用</h2><p>我们只需要在声明成员函数的时候，在成员函数的前面加上virtual关键字，就相当于指示了编译器不要在编译阶段决定这个函数，不要做静态绑定，而是要在程序运行的时候实现动态的绑定，比如上面这个例子，我们就可以在每个类的print函数上如此声明：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//在类外声明print的具体功能</span></span><br><span class="line"><span class="keyword">void</span> Base1::<span class="built_in">print</span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base1:print"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为我们要实现的是在程序运行的时候再去决定函数的函数体到底是哪部分，所以最好就不要把虚函数声明成类中的内联函数，这样会导致在编译过程中直接嵌入到代码中。这样只要再执行之前写好的display函数，虽然也是调用的基类指针，但是这样就实现了函数体的动态绑定，根据传入指针的类型不同调用不同的print函数。（虚函数再编译过程中编译器不做决定，而是根据程序运行时的具体情况做决定）<br>注意，虚函数必须是非静态的成员函数，因为它是动态的，换句话说虚函数是属于具体的对象而不是属于类的，它是需要在程序运行后通过指针指向具体的对象，再判断对象的具体类，再决定调用哪个函数体。</p>
<h2 id="virtual函数使用总结"><a href="#virtual函数使用总结" class="headerlink" title="virtual函数使用总结"></a>virtual函数使用总结</h2><ul>
<li>一般成员函数可以是虚函数，构造函数不能是虚函数，析构函数可以是虚函数</li>
<li>virtual关键字只能在函数原型的声明时添加，而不能在成员函数的实现时</li>
<li>在派生类中，可以直接对基类的虚函数进行覆盖</li>
<li>虚函数一般不声明为内联函数，因为虚函数是运行时动态调用函数体的，而内联函数在处理时是静态的</li>
<li>如果基类声明了virtual关键字的虚函数，在继承时派生类中默认会把这个函数继承成virtual类型（如果继承的虚函数不写virtual关键字，系统会判定这个函数和基类的虚函数原型是否一致，如果一致就会将它也视为虚函数）</li>
<li>派生类中的虚函数会隐藏基类中同名函数的所有其他重载形式，如果需要调用基类中虚函数的其他重载形式，还是需要指定类名</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>虚函数</tag>
      </tags>
  </entry>
  <entry>
    <title>c++虚函数(续)</title>
    <url>/2020/10/21/c-%E8%99%9A%E5%87%BD%E6%95%B0-%E7%BB%AD/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>c++中的虚函数除了写到的内容之外,还有一些用法,这次就把它们全部补齐吧。</p>
<a id="more"></a>
<h2 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h2><p>上篇文章中说到，析构函数也是可以声明为虚函数的，如果你打算允许通过基类指针调用对象的析构函数（通过delete函数，这样是合法的），就需要让基类的虚构函数变成虚函数，否则执行delete的结果将是不确定的。<br>来看一个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ~Base();</span><br><span class="line">&#125;;</span><br><span class="line">Base::~Base()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base destructor"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ~Derived();</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> *p;</span><br><span class="line">&#125;</span><br><span class="line">Derived::Derived()</span><br><span class="line">&#123;</span><br><span class="line">    p = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">Derived::~Derived()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived destructor"</span>;</span><br><span class="line">    <span class="keyword">delete</span> *p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(Base *obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base *b = <span class="keyword">new</span> Derived();</span><br><span class="line">    del(b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">Base destructor</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们想要的效果是通过del函数，释放掉指针指向的内存空间，但是输出结果确实只删除了基类对象。这是因为析构函数不是虚函数，所以在编译阶段编译器就要决定删除这个指针所指向的空间，由于它只知道现在的状态是基类的对象，所以它只能调用基类的析构函数，因为我们派生类的空间没有被释放，这就会导致内存泄漏。<br>而为了解决这个问题，我们只需要将基类和派生类析构函数定义为虚函数，这样在编译过程中，编译器就不会直接静态绑定基类的析构函数，而是在运行过程中，动态的执行。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">virtual</span> ~Base();</span><br><span class="line">&#125;;</span><br><span class="line">Base::~Base()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base destructor"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">virtual</span> ~Derived();</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> *p;</span><br><span class="line">&#125;</span><br><span class="line">Derived::Derived()</span><br><span class="line">&#123;</span><br><span class="line">    p = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">Derived::~Derived()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived destructor"</span>;</span><br><span class="line">    <span class="keyword">delete</span> *p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(Base *obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base *b = <span class="keyword">new</span> Derived();</span><br><span class="line">    del(b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">Derived destructor</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="虚表与动态绑定"><a href="#虚表与动态绑定" class="headerlink" title="虚表与动态绑定"></a>虚表与动态绑定</h2><p>那么在运行的时候，虚函数是怎么实现动态绑定的呢？每个多态类都有一个虚表，这个虚表中有当前类各个虚函数的入口，而在每个对象中也都有指向当前类虚表的指针。具体实现过程如下：</p>
<ul>
<li>构造函数中为对象的虚指针赋值</li>
<li>通过多态类型的指针或引用调用成员函数时，通过虚指针找到虚表，进而找到虚函数的入口</li>
<li>最后通过该入口地址调用虚函数<br>来一个图示（图源清华在线）：<br><img src="/images/14.png" alt=""><h2 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h2>虚函数中还有一种特殊的存在，纯虚函数，这种函数没有自己本身的函数体，具体用法是这样的：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//virtual + 函数 + =0</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
也正是因为这种函数没有函数体，所以拥有纯虚函数的类无法实例化为具体的对象，一般也把这样的类称之为抽象类<br>那么既然这种类无法实例化为具体的对象，那它还有什么作用呢？抽象类更重要的是最为一种规范，它作为基类，为它的派生类规定了函数的写法，让代码更加规范，这样也充分的利用了虚函数动态绑定的特性。（虽然不能将抽象类实例化，但是可以使用抽象类的指针让它指向它的派生类等等）</li>
</ul>
<h2 id="override和final"><a href="#override和final" class="headerlink" title="override和final"></a>override和final</h2><p>在c++11中，在使用类的时候新增了两个关键字，override和final，它们在我们对类进行继承操作时可以起到很大的帮助</p>
<h3 id="override"><a href="#override" class="headerlink" title="override"></a>override</h3><p>override是重载函数的关键字，当我们在一个派生类中想要对基类的函数进行重载时，可以加入override关键字，这样在编译的过程中，编译器会将你想要重载的函数看作是函数的重载，并且在基类中寻找同名的被重载函数，如果找不到则直接报错，虽然c++默认就带有继承功能，但是使用override之后可以避免很多因为函数名书写错误或由于函数是const类型而导致的重载失败。</p>
<h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><p>当我们想保证一个类或其中函数的稳定性，让它不能被继承，我们就可以使用final关键字，当类加上final关键字，这个类将不能被继承，而当函数中的类加上final关键字，虽然这个类可以被继承，但是在继承类中不能对这个函数进行重载操作，否则会报错。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>虚函数</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#530</title>
    <url>/2020/10/12/LeetCode-530/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="LeetCode-530"><a href="#LeetCode-530" class="headerlink" title="LeetCode#530"></a>LeetCode#530</h2><a id="more"></a>
<p><a href="https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/" target="_blank" rel="noopener">题目链接</a><br>题意的意思是给你一个二叉树，然后找到二叉树中所有节点里绝对值差最小的值，我用了一个比较笨的方法，将树遍历，然后排序，再遍历一遍数组即可，先附代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* node,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;ve)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        ve.push_back(node-&gt;val);</span><br><span class="line">        dfs(node-&gt;right,ve);</span><br><span class="line">        dfs(node-&gt;left,ve);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;ve;</span><br><span class="line">        dfs(root,ve);</span><br><span class="line">        <span class="keyword">if</span>(ve.<span class="built_in">size</span>() == <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">abs</span>(ve[<span class="number">0</span>]-ve[<span class="number">1</span>]);</span><br><span class="line">        sort(ve.<span class="built_in">begin</span>(),ve.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; ve.<span class="built_in">size</span>()<span class="number">-1</span> ;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> cur = <span class="built_in">min</span>(<span class="built_in">abs</span>(ve[i]-ve[i<span class="number">-1</span>]),<span class="built_in">abs</span>(ve[i]-ve[i+<span class="number">1</span>]));</span><br><span class="line">            <span class="keyword">if</span>(ans == <span class="number">-1</span>)</span><br><span class="line">                ans = cur;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ans = ans &lt; cur ? ans: cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>看了一下题解，整体思路类似，但是题解用了更优的解法，首先是一个我没注意到的条件，二叉搜索树<del>眼睛是个好东西</del>，这样就保证了只要使用中序遍历，即可保证获得的数组是排好序的数组；然后就是我们可以一边遍历一边取最小的差值，这样就又节省了遍历数组的时间复杂度，和开辟新的数组的额外空间复杂度……<br>附代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span>&amp; pre, <span class="keyword">int</span>&amp; ans)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root-&gt;left, pre, ans);</span><br><span class="line">        <span class="keyword">if</span> (pre == <span class="number">-1</span>) &#123;</span><br><span class="line">            pre = root-&gt;val;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, root-&gt;val - pre);</span><br><span class="line">            pre = root-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root-&gt;right, pre, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = INT_MAX, pre = <span class="number">-1</span>;</span><br><span class="line">        dfs(root, pre, ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#416</title>
    <url>/2020/10/11/LeetCode-416/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="LeetCode-416分割等和子集"><a href="#LeetCode-416分割等和子集" class="headerlink" title="LeetCode#416分割等和子集"></a>LeetCode#416分割等和子集</h2><a id="more"></a>
<p><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/" target="_blank" rel="noopener">题目链接</a><br>题面很简单，意思就是给你个数组，然后问能否把这个数组分成加和相等的两个子数组，能的话返回true，否则返回false。首先能想到以下几种一定返回false：</p>
<ul>
<li>如果加和的sum为奇数则一定不能等分</li>
<li>如果数组中的元素数量n&lt;2一定不能等分</li>
<li>如果数组中有一个元素大于sum/2一定不能等分（为了降低时间复杂度，我们只需要判断数组中最大的数和sum/2的关系即可）<br>一开始我的想法是使用递归，遍历一遍整个数组，在每个数上判断一下选择或者不选择，但是直接tle了（这样递归的时间复杂度是2^n，我算成n^2了<del>人傻了</del>）<br>附一个递归的代码：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="keyword">int</span> pos,<span class="keyword">int</span> cnt,<span class="keyword">int</span>&amp; sum,<span class="keyword">bool</span>&amp; flag)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt == sum)</span><br><span class="line">        &#123;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt &gt; sum)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(pos == nums.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        dfs(nums,pos+<span class="number">1</span>,cnt+nums[pos],sum,flag);</span><br><span class="line">        dfs(nums,pos+<span class="number">1</span>,cnt,sum,flag);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canPartition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.<span class="built_in">size</span>() ; i++)</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        <span class="keyword">if</span>(sum%<span class="number">2</span>==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            sum/=<span class="number">2</span>;</span><br><span class="line">            dfs(nums,<span class="number">0</span>,<span class="number">0</span>,sum,flag);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
而正确的解法应该是使用动态规划，和我的想法差不多，也是判断每个数选择或者不选择，这样就可以把这道题模型化为01背包<del>还是菜没想到</del><br>dp[i][j]的含义是当使用数组中的前i个数，能否组合成j<br>初始化dp数组有几个情况：</li>
<li>当i=0的时候，即只使用数组中第0个数，dp[0][num[0]]=true</li>
<li>当j=0的时候，不选择任何数即可满足条件，所以dp[i][0]=true<br><del>dp[i][num[i]]=true也是成立的，但是好像没啥用</del><br>动态转移方程分为两种情况：</li>
<li>选取num[i],dp[i][j] = dp[i-1][j-num[i]]</li>
<li>不选取num[i],dp[i][j]=dp[i-1][j]</li>
</ul>
<p>附代码之前，再记录两个从来没用过的函数，accumulate()和*max_element()。<br>accumulate()函数在#include<numeric>头文件中，作用是累加求和，当然，你也可以自定义类型求和(数据处理)。accumulate带有三个形参：头两个形参指定要累加的元素范围，第三个形参则是累加的初值，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = accumulate(vec.<span class="built_in">begin</span>() , vec.<span class="built_in">end</span>() , <span class="number">42</span>);  <span class="comment">//求vector容器所有元素的累加和，累加初值设为42</span></span><br></pre></td></tr></table></figure>
<p>还有种另类用法是将整形vector转换为字符串，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> sum = accumulate(v.<span class="built_in">begin</span>() , v.<span class="built_in">end</span>() , <span class="built_in">string</span>(<span class="string">" "</span>));</span><br></pre></td></tr></table></figure>

<p><em>max_element()函数，返回容器中的最大值，相对应的，</em>min_element()函数返回容器/数组中的最小值，它们都在#include<algorithm>头文件中。</p>
<p>附代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canPartition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = accumulate(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> maxNum = *max_element(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">if</span> (sum &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> target = sum / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (maxNum &gt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(target + <span class="number">1</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>][nums[<span class="number">0</span>]] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> num = nums[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= target; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= num) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] | dp[i - <span class="number">1</span>][j - num];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>新博客的第一篇文章</title>
    <url>/2020/07/06/%E6%96%B0%E5%8D%9A%E5%AE%A2%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>折腾了一周时间终于搭好了基于hexo的个人博客，使用了next主题 <del>（主要是可以白嫖github的域名和静态页面）</del><br>接下来博客还有很多需要完善的地方<del>（以及美化（逃））</del></p>
<a id="more"></a>
<p><strong>预计功能有：</strong></p>
<ul>
<li>阅读量统计</li>
<li>评论区</li>
<li>以及美化 and so on…</li>
</ul>
<p>希望自己能坚持下来，将写博客这个好习惯保持下去</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>添加评论</title>
    <url>/2020/07/07/%E6%B7%BB%E5%8A%A0%E8%AF%84%E8%AE%BA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>我发现next主题真的是个好东西，什么东西都给我们写好了，添加很多组件都很方便。接下来记录一下如何添加讨论区。</p>
<a id="more"></a>
<p>hexo上可用的讨论区有很多：valine、来必力、disqus、facebookcomments等等，这里选择valine作为博客使用的主力评论系统。valine是完全基于静态页面的本地评论区，加载迅速而且上手简单，而且支持markdown（简直不要太爽）。</p>
<p>valine也是基于leancloud的服务，所以和添加阅读数量一样也需要先注册一个leancloud，并且在存储中新建一个comment类（可以参考我的)，其他操作相同）然后在next主题的配置文件中对valine进行配置。<br><img src="/images/4.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enable:&#x2F;&#x2F;是否开启valine评论</span><br><span class="line">appid: &#x2F;&#x2F;你自己的id</span><br><span class="line">appkey: &#x2F;&#x2F;你自己的key</span><br><span class="line">notify: &#x2F;&#x2F;是否通过邮箱通知你</span><br><span class="line">verify: &#x2F;&#x2F;是否验证（反人类建议关闭）</span><br><span class="line">placeholder: &#x2F;&#x2F;评论区的默认标语</span><br><span class="line">avatar: &#x2F;&#x2F;头像</span><br><span class="line">guest_info: &#x2F;&#x2F;评论的人需要填什么信息</span><br><span class="line">pageSize: &#x2F;&#x2F;每页几个评论</span><br><span class="line">language: &#x2F;&#x2F;语言</span><br><span class="line">visitor: &#x2F;&#x2F;文章阅读稳定性相关（不太懂）</span><br><span class="line">comment_count:&#x2F;&#x2F;评论计数</span><br><span class="line">recordIP: &#x2F;&#x2F;记录ip（别人看不到）</span><br><span class="line">serverURLs: &#x2F;&#x2F;如果他没填写昵称的话显示的东西</span><br></pre></td></tr></table></figure>
<p>开启评论之后，会在每个页面都显示评论，如果我们不想让它显示评论呢？（比如标签页和分类页）</p>
<p>我们就需要在这篇文章的头部部分加上：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">comment:false</span><br></pre></td></tr></table></figure>
<p><img src="/images/5.png" alt=""><br>作为一个强迫症，在添加评论数后，头部没有做到全部汉化，评论数还显示valine是我难以忍受的，这是因为next默认支持多种评论区，所以默认显示当前开启了何种评论所以我们可以自己编译一下。在next文件夹中找到language文件夹，找到你当前已选择语言的yml文件对应的post部分（我用的中文，所以就在zh_CN.yml文件里），按照上面的样式添加一条：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">comments.valine: 评论数&#x2F;&#x2F;注意一定要有个空格</span><br></pre></td></tr></table></figure>
<p>效果如图：<br><img src="/images/6.png" alt=""></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>评论</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>VScode配置c++环境</title>
    <url>/2020/10/11/VScode%E9%85%8D%E7%BD%AEc-%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>重装系统之后，许多环境变量都需要重新配置…这次使用了一个不同方法来配置Windows下使用VScode c++的方法。</p>
<a id="more"></a>
<p><a href="https://zhuanlan.zhihu.com/p/77645306" target="_blank" rel="noopener">参考链接</a></p>
<h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><p>vscode本质上只是一个文本编辑器<del>大佬都用记事本写代码</del>，所以首先我们需要安装c/c++的编译环境，这里我选择的是mingw（<a href="https://sourceforge.net/projects/mingw-w64/files/Toolchains%20targetting%20Win64/Personal%20Builds/mingw-builds/8.1.0/threads-posix/seh/x86_64-8.1.0-release-posix-seh-rt_v6-rev0.7z/download" target="_blank" rel="noopener">下载地址</a>）。下载好之后，解压到一个你找得到的文件夹（我的是C:\MinGW-w64，下面的内容都基于这个路径），然后右键计算机-高级系统设置-环境变量，然后在下方的系统变量中找到Path，双击打开，新建一个环境变量，地址填为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\MinGW-w64\bin</span><br></pre></td></tr></table></figure>
<p>这个是我自己的路径，你们需要把前面的替换为自己刚才解压好的那个路径，保存并确定。然后运行cmd，输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -v</span><br></pre></td></tr></table></figure>
<p>如果正常显示了编译器的版本，则证明配置成功，否则就需要检查你是否哪步出现了问题。</p>
<h2 id="VScode插件安装及配置"><a href="#VScode插件安装及配置" class="headerlink" title="VScode插件安装及配置"></a>VScode插件安装及配置</h2><p>在VScode端，为了代码的美观性以及能够系统及时的给我们纠正错误，我们需要安装一个名为C/C++的官方拓展，如果想要简体中文，还需要安装chinese(simplified)拓展。<br>接下来找一个你经常写代码的文件夹（注意不要在路径中包含中文名，否则会产生奇奇怪怪的bug），然后用VScode打开，在这个文件夹中新建一个文件夹名为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.vscode&#x2F;&#x2F;注意有个点</span><br></pre></td></tr></table></figure>
<p>再在.vscode文件夹中新建两个文件，分别为launch.json和tasks.json，然后在两个文件中填入如下内容：<br>launch.json</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"version"</span>: <span class="string">"0.2.0"</span>,</span><br><span class="line">    <span class="attr">"configurations"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"C/C++"</span>,</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"cppdbg"</span>,</span><br><span class="line">            <span class="attr">"request"</span>: <span class="string">"launch"</span>,</span><br><span class="line">            <span class="attr">"program"</span>: <span class="string">"$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe"</span>,</span><br><span class="line">            <span class="attr">"args"</span>: [],</span><br><span class="line">            <span class="attr">"stopAtEntry"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">"cwd"</span>: <span class="string">"$&#123;workspaceFolder&#125;"</span>,</span><br><span class="line">            <span class="attr">"environment"</span>: [],</span><br><span class="line">            <span class="attr">"externalConsole"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">"MIMode"</span>: <span class="string">"gdb"</span>,</span><br><span class="line">            <span class="attr">"miDebuggerPath"</span>: <span class="string">"gdb.exe"</span>,</span><br><span class="line">            <span class="attr">"preLaunchTask"</span>: <span class="string">"compile"</span>,</span><br><span class="line">            <span class="attr">"setupCommands"</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"description"</span>: <span class="string">"Enable pretty-printing for gdb"</span>,</span><br><span class="line">                    <span class="attr">"text"</span>: <span class="string">"-enable-pretty-printing"</span>,</span><br><span class="line">                    <span class="attr">"ignoreFailures"</span>: <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">        &#125;,</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>tasks.json</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"version"</span>: <span class="string">"2.0.0"</span>,</span><br><span class="line">    <span class="attr">"tasks"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"shell"</span>,</span><br><span class="line">            <span class="attr">"label"</span>: <span class="string">"compile"</span>,</span><br><span class="line">            <span class="attr">"command"</span>: <span class="string">"g++"</span>,</span><br><span class="line">            <span class="attr">"args"</span>: [</span><br><span class="line">                <span class="string">"-g"</span>,</span><br><span class="line">                <span class="string">"$&#123;file&#125;"</span>,</span><br><span class="line">                <span class="string">"-o"</span>,</span><br><span class="line">                <span class="string">"$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe"</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">"problemMatcher"</span>: [</span><br><span class="line">                <span class="string">"$gcc"</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">"group"</span>: &#123;</span><br><span class="line">                <span class="attr">"kind"</span>: <span class="string">"build"</span>,</span><br><span class="line">                <span class="attr">"isDefault"</span>: <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好了，现在在这个你常写代码的文件夹中打开一个c/c++文件试试看吧，只需要按f5或者左侧的运行按钮，即可对你的代码进行调试了，enjoy it~</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title>添加网抑云音乐播放</title>
    <url>/2020/09/29/%E6%B7%BB%E5%8A%A0%E7%BD%91%E6%8A%91%E4%BA%91%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>为博客添加一个网抑云播放的小插件。</p>
<a id="more"></a>
<p>我使用的方法是网抑云自带的外链，使用起来非常的简单，但是效果也比较单一（也可以播放歌单，但是我觉得效果不是很好）</p>
<h2 id="具体方法如下："><a href="#具体方法如下：" class="headerlink" title="具体方法如下："></a>具体方法如下：</h2><ul>
<li>首先选择一首你喜欢的歌</li>
<li>然后选择生成外链（注意这歌必须得是非会员且有版权的，要不生成不了）</li>
<li>在生成的外链中设置你的播放器尺寸，以及是否自动播放<br>例如：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;iframe frameborder&#x3D;&quot;no&quot; border&#x3D;&quot;0&quot; marginwidth&#x3D;&quot;0&quot; marginheight&#x3D;&quot;0&quot; width&#x3D;330 height&#x3D;86 src&#x3D;&quot;&#x2F;&#x2F;music.163.com&#x2F;outchain&#x2F;player?type&#x3D;2&amp;id&#x3D;433681730&amp;auto&#x3D;1&amp;height&#x3D;66&quot;&gt;&lt;&#x2F;iframe&gt;</span><br><span class="line">&#x2F;&#x2F;其中width和height分别为宽度和高度，auto &#x3D; 1为自动播放，0为非自动播放</span><br></pre></td></tr></table></figure></li>
<li>然后找到你主题的配置部分，选择你想加入插件的位置，我的是next主题，想要把播放插件加到侧边栏上，所以我就需要下面的文件中填加这些内容：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;themes&#x2F;next&#x2F;layout&#x2F;_macro&#x2F;siderbar.swig</span><br><span class="line">&#123;% macro render(display_toc) %&#125;</span><br><span class="line">  &lt;div class&#x3D;&quot;toggle sidebar-toggle&quot;&gt;</span><br><span class="line">    &lt;span class&#x3D;&quot;toggle-line toggle-line-first&quot;&gt;&lt;&#x2F;span&gt;</span><br><span class="line">    &lt;span class&#x3D;&quot;toggle-line toggle-line-middle&quot;&gt;&lt;&#x2F;span&gt;</span><br><span class="line">    &lt;span class&#x3D;&quot;toggle-line toggle-line-last&quot;&gt;&lt;&#x2F;span&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">  &lt;aside class&#x3D;&quot;sidebar&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;sidebar-inner&quot;&gt;</span><br><span class="line"></span><br><span class="line">      &#123;%- set display_toc &#x3D; page.toc.enable and display_toc %&#125;</span><br><span class="line">      &#123;%- if display_toc %&#125;</span><br><span class="line">        &#123;%- set toc &#x3D; toc(page.content, &#123; class: &quot;nav&quot;, list_number: page.toc.number, max_depth: page.toc.max_depth &#125;) %&#125;</span><br><span class="line">        &#123;%- set display_toc &#x3D; toc.length &gt; 1 and display_toc %&#125;</span><br><span class="line">      &#123;%- endif %&#125;</span><br><span class="line"></span><br><span class="line">      &lt;ul class&#x3D;&quot;sidebar-nav motion-element&quot;&gt;</span><br><span class="line">        &lt;li class&#x3D;&quot;sidebar-nav-toc&quot;&gt;</span><br><span class="line">          &#123;&#123; __(&#39;sidebar.toc&#39;) &#125;&#125;</span><br><span class="line">        &lt;&#x2F;li&gt;</span><br><span class="line">        &lt;li class&#x3D;&quot;sidebar-nav-overview&quot;&gt;</span><br><span class="line">          &#123;&#123; __(&#39;sidebar.overview&#39;) &#125;&#125;</span><br><span class="line">        &lt;&#x2F;li&gt;</span><br><span class="line">      &lt;&#x2F;ul&gt;</span><br><span class="line"></span><br><span class="line">      &lt;!--noindex--&gt;</span><br><span class="line">      &lt;div class&#x3D;&quot;post-toc-wrap sidebar-panel&quot;&gt;</span><br><span class="line">        &#123;%- if display_toc %&#125;</span><br><span class="line">          &lt;div class&#x3D;&quot;post-toc motion-element&quot;&gt;&#123;&#123; toc &#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">        &#123;%- endif %&#125;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">      &lt;!--&#x2F;noindex--&gt;</span><br><span class="line"></span><br><span class="line">      &lt;div class&#x3D;&quot;site-overview-wrap sidebar-panel&quot;&gt;</span><br><span class="line">        &#123;&#123; partial(&#39;_partials&#x2F;sidebar&#x2F;site-overview.swig&#39;, &#123;&#125;, &#123;cache: theme.cache.enable&#125;) &#125;&#125;</span><br><span class="line"></span><br><span class="line">        &#123;&#123;- next_inject(&#39;sidebar&#39;) &#125;&#125;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">      &#123;%- if theme.back2top.enable and theme.back2top.sidebar %&#125;</span><br><span class="line">        &lt;div class&#x3D;&quot;back-to-top motion-element&quot;&gt;</span><br><span class="line">          &lt;i class&#x3D;&quot;fa fa-arrow-up&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">          &lt;span&gt;0%&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">      &#123;%- endif %&#125;</span><br><span class="line">      &lt;iframe frameborder&#x3D;&quot;no&quot; border&#x3D;&quot;0&quot; marginwidth&#x3D;&quot;0&quot; marginheight&#x3D;&quot;0&quot; width&#x3D;280 height&#x3D;86 src&#x3D;&quot;&#x2F;&#x2F;music.163.com&#x2F;outchain&#x2F;player?type&#x3D;2&amp;id&#x3D;433681730&amp;auto&#x3D;1&amp;height&#x3D;66&quot;&gt;&lt;&#x2F;iframe&gt;&#x2F;&#x2F;这是你自己的内容</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;aside&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;sidebar-dimmer&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&#123;% endmacro %&#125;</span><br></pre></td></tr></table></figure>
enjoy it~</li>
</ul>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>添加音乐</tag>
      </tags>
  </entry>
  <entry>
    <title>搜索功能</title>
    <url>/2020/09/22/%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>一直觉得blog的搜索功能很有用<del>装x</del>，方便我们来查找自己曾经写过的东西，所以今天按照大佬的方法给博客加了个搜索的功能，操作很简单，有手就行<del>没有也行</del></p>
<a id="more"></a>
<p><a href="https://blog.csdn.net/lijing742180/article/details/87970909" target="_blank" rel="noopener">参考链接</a></p>
<ul>
<li>首先切换到博客目录下，安装hexo的搜索插件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure>
安装后会自动创建一个search.xml，我个人理解是相当于创建了索引（因为是纯静态页面嘛）</li>
<li>然后修改hexo的配置文件_config.yml（注意不是主题的），添加如下内容：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Search </span><br><span class="line">search:</span><br><span class="line">  path: .&#x2F;public&#x2F;search.xml &#x2F;&#x2F;索引的位置</span><br><span class="line">  field: post &#x2F;&#x2F;搜索的范围，默认post，也可以手动设置all、page等等</span><br><span class="line">  format: html &#x2F;&#x2F;搜索的类型</span><br><span class="line">  limit: 10000 &#x2F;&#x2F;限制搜索的条目数</span><br></pre></td></tr></table></figure></li>
<li>接下来只要配置好主题相关内容就可以了，因为我用的是next主题，默认就有搜索功能的支持，所以我只要选择打开这个功能就可以了。在next的_config.xml文件中搜索local_search，然后做如下修改：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">local_search:</span><br><span class="line">  enable: true &#x2F;&#x2F;开启搜索功能</span><br><span class="line">  trigger: auto</span><br><span class="line">  top_n_per_article: 1</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>本地搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>添加阅读次数</title>
    <url>/2020/07/07/%E6%B7%BB%E5%8A%A0%E9%98%85%E8%AF%BB%E6%AC%A1%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>博客添加阅读次数是一件很有用<del>装逼</del>的事情，以下均是基于GitHub page+hexo+next主题进行配置。</p>
<a id="more"></a>
<p>首先需要用到leancloud的服务，首先我们需要注册一个<a href="https://leancloud.cn/dashboard/login.html" target="_blank" rel="noopener">leancloud</a>，登陆后创建一个开发版的应用,这里面应用名称可随意填写 <del>（反正也可以改）</del>。<br><img src="/images/1.png" alt=""></p>
<p>然后在存储中创建一个名为Conter的新class（注意权限都为所有用户）<br><img src="/images/2.png" alt=""></p>
<p>然后在设置-安全中心-Web安全域名中填入自己博客的域名，以防被ban导致无法使用，然后进入应用Keys，将AppID和AppKey都复制下来一会会用到。</p>
<p>接下来是本地的配置，由于next默认是支持这个功能的，所以我们只需要开启就好了，在next主题根目录下找到_config.yml文件，按照如图所示进行修改（appid和keyid填你自己的）<br><img src="/images/3.png" alt=""><br>注意一定要把security改为false，否则会提示你计数不可用（当然也有其他办法只不过我不太会233）<br>编译，上传，发现已经搞好了！</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>阅读次数</tag>
        <tag>leancloud</tag>
      </tags>
  </entry>
  <entry>
    <title>红黑树</title>
    <url>/2020/09/15/%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>最近学习数据结构和c++的STL，了解到了map、set的实现都是依靠红黑树，依靠红黑树的这两个容器都有查找速度快，插入删除元素快的特点，下面记录一下红黑树的原理及实现。</p>
<a id="more"></a>
<p><a href="https://www.jianshu.com/p/e136ec79235c" target="_blank" rel="noopener">参考链接</a></p>
<p>红黑树本质上也是一个平衡二叉树，但是它并不是严格意义上的完全平衡二叉树（AVL），而是黑色节点平衡二叉树。</p>
<h3 id="红黑树的几个性质："><a href="#红黑树的几个性质：" class="headerlink" title="红黑树的几个性质："></a>红黑树的几个性质：</h3><ul>
<li>树中只有红色或黑色的节点（每个节点不是红色就是黑色）</li>
<li>根节点是黑色节点</li>
<li>每个叶子节点（NIL）是黑色节点（NIL可以看作是空的叶子节点）</li>
<li>每个红色节点的两个子节点都是黑色</li>
<li>任意节点到每个叶子节点的路径都包含相同数量的黑节点</li>
</ul>
<p>红黑树的查找和普通的二叉树一样，但又因为红黑树总能保证黑色平衡，时间复杂度就为O(2logn)，所以查找的速度很快。</p>
<p>红黑树的插入、删除速度也很快。在c++中，由红黑树构成的数据结构（map、set、multimap、multiset）在插入或者删除操作时不需要操作内存，当插入或删除操作后，它对应的迭代器（itrator）也不需要重新声明，究其原因是因为当进行插入/删除操作时，本质上只是指针的指向进行了改变，而容器内储存的仅仅是节点的关系，而不是真正的数据。新节点也只是加了一个额外的指针进行指向，所以迭代器也可以正常继续使用。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>红黑树</tag>
      </tags>
  </entry>
  <entry>
    <title>vscode远程编程</title>
    <url>/2020/09/23/vscode%E8%BF%9C%E7%A8%8B%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>最近在学习c++的多线程和网络流，突然发现好多函数在windows下无法实现，就想起了尝试一下VSCode的远程编程。</p>
<a id="more"></a>
<p><a href="https://zhuanlan.zhihu.com/p/64849549" target="_blank" rel="noopener">参考链接</a><br>远程编程顾名思义，在本地的VSCodeIDE上连接远程服务器，直接将文件写在远程环境上，当然调试也是在更符合实际服务器工作环境的Linux上进行。<del>Linux确实香，但是真的不喜欢用</del><br>其实这个功能主要是依靠于VSCode最近几个版本终于加入了正式支持的远程编程功能插件，它可以实现：</p>
<ul>
<li>SSH连接虚拟机/实体服务器编程</li>
<li>连接容器</li>
<li>连接WSL（Linux子系统）~~不过我还没用过<br>安装过程其实并不麻烦，我简单的把它分为以下几步：<h2 id="VScode端配置"><a href="#VScode端配置" class="headerlink" title="VScode端配置"></a>VScode端配置</h2>在VSCode上的配置其实很简单，我们首先需要在插件中搜索Remote-SSH，并安装拓展。<br>然后需要在左侧栏中找到你的远程资源管理器，选择新建或者设置ssh\config（这需要你提前安装了Open-SSH，<del>如果这个都没安装的话谈什么远程编程</del>）<br>具体设置如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Host CentOS&#x2F;&#x2F;别名</span><br><span class="line">    HostName 192.168.91.132&#x2F;&#x2F;连接的ip地址</span><br><span class="line">    User root&#x2F;&#x2F;登陆的用户名</span><br><span class="line">    Port 22&#x2F;&#x2F;端口，ssh一般都是22吧</span><br><span class="line">    IdentityFile C:\Users\xxx（用户名）\.ssh\id_rsa&#x2F;&#x2F;你电脑的私钥位置，这样以后就不需要输入密码了</span><br></pre></td></tr></table></figure>
最后一项其实也可以不配置，这样就需要每次输入用户名和密码了。<br>至此，如果你没有设置密钥远程配置就算完成了。<h2 id="密钥生成"><a href="#密钥生成" class="headerlink" title="密钥生成"></a>密钥生成</h2>如果配置密钥的话，首先需要拥有一个密钥，没有生成过密钥的话就执行如下命令：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen</span><br></pre></td></tr></table></figure>
生成密钥的时候一路回车就可以了。<h2 id="密钥上传到服务器"><a href="#密钥上传到服务器" class="headerlink" title="密钥上传到服务器"></a>密钥上传到服务器</h2>然后我们需要把公钥传到服务器上，我使用的方法是直接用git自带的命令：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-copy-id 你的用户名@你的IP</span><br><span class="line">&#x2F;&#x2F;例如我的就可以使用ssh-copy-id root@192.168.91.132</span><br></pre></td></tr></table></figure>
或者你也可以手动将密钥上传到服务器，也就是将你id_rsa.pub里的内容全部复制到服务器的.ssh/authorized_keys文件中，这样和上面的实现的效果是一样的<br>这下就基本完成了，只需要再启动一下你的远程窗口就ok了，enjoy it~</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>vscode</tag>
        <tag>远程编程</tag>
      </tags>
  </entry>
  <entry>
    <title>为hexo博客添加全局aplayer播放器</title>
    <url>/2020/10/13/%E4%B8%BAhexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E5%85%A8%E5%B1%80aplayer%E6%92%AD%E6%94%BE%E5%99%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>前一阵子在博客搞了个，歌单状态下不显示歌名，最重要的是当切换页面的时候音乐会重新播放<del>忍不了了</del>，今天终于搞明白了aplayer这个好东西，不仅可以配合meting使用网络歌单，还可以配合pjax实现全站的跨页面不刷新播放。</p>
<a id="more"></a>
<p>此篇博客参考了这位大佬的好多思路，附<a href="https://hakurei.red/2019/11/25/%E4%B8%BAHexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E5%85%A8%E5%B1%80APlayer%E6%92%AD%E6%94%BE%E5%99%A8/#APlayer" target="_blank" rel="noopener">链接</a></p>
<h2 id="Aplayer和Meting的配置"><a href="#Aplayer和Meting的配置" class="headerlink" title="Aplayer和Meting的配置"></a>Aplayer和Meting的配置</h2><p>Aplayer是一个开源的，网页端的播放器，这是它的<a href="https://aplayer.js.org/#/zh-Hans/" target="_blank" rel="noopener">使用文档</a>，这个播放器可以支持播放本地自定义的音频、歌词、专辑封面等等，但是由于我是想直接使用网络端的歌单，所以直接跳过了这一步，本地使用方法可以直接参考使用文档，写的很详细。<br>接下来的重头戏是直接使用meting实现网络歌单，我是想在所有页面的固定位置显示这个播放模块，正好aplayer自带的吸底模式(翻译为fixed，有点难理解)符合我的要求，它会始终出现在网页的左下角，配合pjax实现不刷新内容，简直不要太爽。<br>我使用的是hexo+next的博客，我想在所有页面都实现这个效果，所以我需要找到主题的页面布局文件，\themes\next\layout\ _layoout.swig<br>首先在body中添加依赖：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css"</span>&gt;</span><span class="comment">&lt;!--APlayer的样式--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="comment">&lt;!--APlayer的依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="comment">&lt;!--Meting的依赖--&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里我们指定了版本，因为meting的新版本和aplayer有奇怪的兼容性问题…<br>然后就是使用metingjs了，首先附一个官方的<a href="https://github.com/metowolf/MetingJS" target="_blank" rel="noopener">使用文档</a>，使用方法也非常的简单，直接看代码吧：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meting-js</span></span></span><br><span class="line"><span class="tag">	<span class="attr">server</span>=<span class="string">"netease"</span>//歌单的服务商，比如<span class="attr">netease</span>代表网易云，<span class="attr">tencent</span>代表<span class="attr">qq</span>音乐等等</span></span><br><span class="line"><span class="tag">	<span class="attr">type</span>=<span class="string">"playlist"</span>//类型，单曲或歌单</span></span><br><span class="line"><span class="tag">  <span class="attr">autoplay</span>=<span class="string">true</span> //打开网页自动播放</span></span><br><span class="line"><span class="tag">  <span class="attr">fixed</span>=<span class="string">true</span> //使用吸底模式</span></span><br><span class="line"><span class="tag">	<span class="attr">id</span>=<span class="string">"5286851482"</span>&gt;</span> //歌单的id，在网页端可以直接查看</span><br><span class="line"><span class="tag">&lt;/<span class="name">meting-js</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>保存，重启服务之后发现已经出现了吸底的浮窗</p>
<h2 id="pjax的配置"><a href="#pjax的配置" class="headerlink" title="pjax的配置"></a>pjax的配置</h2><p>配置完aplayer，接下来就是配置跨页面不刷新了。由于我使用的是next主题，其实next主题已经想到了可能是用的pjax，所以我们只需要安装依赖，并且在config中启用即可。<br>首先安装依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd themes&#x2F;next</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;theme-next-pjax source&#x2F;lib&#x2F;pjax</span><br></pre></td></tr></table></figure>
<p>然后我们只需要在next的_config.yml中找到pjax选项，将false改为true即可<br>enjoy it~</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>aplayer</tag>
        <tag>pjax</tag>
      </tags>
  </entry>
</search>
