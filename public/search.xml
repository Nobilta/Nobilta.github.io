<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>hexo-next主题的美化</title>
    <url>/2020/07/08/hexo-next%E4%B8%BB%E9%A2%98%E7%9A%84%E7%BE%8E%E5%8C%96/</url>
    <content><![CDATA[<p>博客已经基本能用了，剩下就是一些强迫症的美化工作了，next主题默认的是极简的黑白风配色，官方并没有提供相对应的接口进行颜色的修改，参考了<a href="https://zhouhuix.cn/2016/11/24/%E4%BF%AE%E6%94%B9Hexo%E7%9A%84Next%E4%B8%BB%E9%A2%98/" target="_blank" rel="noopener">大佬的一篇博客</a>以及另一篇<a href="https://www.jianshu.com/p/2a8d399f1266" target="_blank" rel="noopener">大佬的自定义内容</a>，对配色进行了简单的修改，然后就是点击效果的修改和其他亿些细节的修改。</p>
<a id="more"></a>
<h1 id="修改配色"><a href="#修改配色" class="headerlink" title="修改配色"></a>修改配色</h1><p>打开hexo/themes/next/source/css/_variables/base.styl，找到如下内容：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">$whitesmoke   = #f5f5f5;</span><br><span class="line">$gainsboro    = #eee;</span><br><span class="line">$grey-lighter = #ddd;</span><br><span class="line">$grey-light   = #ccc;</span><br><span class="line">$grey         = #bbb;</span><br><span class="line">$grey-dark    = #999;</span><br><span class="line">$grey-dim     = #666;</span><br><span class="line">$black-light  = #555;</span><br><span class="line">$black-dim    = #333;</span><br><span class="line">$black-deep   = #70b7fd;//这是我们需要修改的，默认为#555</span><br><span class="line">$red          = #ff2a2a;</span><br><span class="line">$blue-bright  = #87daff;</span><br><span class="line">$blue         = #0684bd;</span><br><span class="line">$custom_blue  = #70b7fd;//这是我自己添加的，可以不加</span><br><span class="line">$blue-deep    = #262a30;</span><br><span class="line">$orange       = #fc6423;</span><br></pre></td></tr></table></figure>
<p>其实这并不是最优的解法，因为这其实是全局替换了一个颜色，所有用到这个颜色的都会被替换成修改过的颜色（然而我并没有搞明白具体在哪单独修改，如果有大佬可以指导我一下就太好了，<del>这个大坑等以后来填</del>）</p>
<p>为了让效果更好，我们还要再额外添加一些自定义内容，但根据第二篇大佬的博客，custom文件夹已经不见了，在评论区我找到了新版本的解法：</p>
<ul>
<li>首先在next主题的config文件中将style取消注释，这样就可以开启自定义的样式了<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">custom_file_path:</span></span><br><span class="line">  <span class="comment">#head: source/_data/head.swig</span></span><br><span class="line">  <span class="comment">#header: source/_data/header.swig</span></span><br><span class="line">  <span class="comment">#sidebar: source/_data/sidebar.swig</span></span><br><span class="line">  <span class="comment">#postMeta: source/_data/post-meta.swig</span></span><br><span class="line">  <span class="comment">#postBodyEnd: source/_data/post-body-end.swig</span></span><br><span class="line">  <span class="attr">footer:</span> <span class="string">source/_data/footer.swig</span></span><br><span class="line">  <span class="comment">#bodyEnd: source/_data/body-end.swig</span></span><br><span class="line">  <span class="comment">#variable: source/_data/variables.styl</span></span><br><span class="line">  <span class="comment">#mixin: source/_data/mixins.styl</span></span><br><span class="line">  <span class="attr">style:</span> <span class="string">source/_data/styles.styl</span></span><br></pre></td></tr></table></figure>
在/source中新建_data文件夹，再新建styles.styl文件（其实其他位置其他文件名也没问题，但是需要在上面进行修改），再在styles文件里加入如下代码：<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">// 修改网站头部颜色</span><br><span class="line"><span class="selector-class">.headband</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">3px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#70b7fd</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.site-meta</span> &#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">20px</span> <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#70b7fd</span>;</span><br><span class="line">&#125;</span><br><span class="line">//这个似乎没啥用...</span><br><span class="line"><span class="selector-class">.site-subtitle</span> &#123;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">13px</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#ffffff</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 修改按键（button）样式</span><br><span class="line"><span class="selector-class">.btn</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#70b7fd</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">2px</span> solid <span class="number">#70b7fd</span>;</span><br><span class="line">&#125;</span><br><span class="line">// 按键（button）点击时样式</span><br><span class="line"><span class="selector-class">.btn</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">border-color</span>: <span class="number">#70b7fd</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#70b7fd</span>;</span><br><span class="line">&#125;</span><br><span class="line">// 鼠标移动至文章标题时的效果</span><br><span class="line"><span class="selector-class">.posts-expand</span> <span class="selector-class">.post-title-link</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">2px</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#70b7fd</span>;</span><br><span class="line">    <span class="attribute">visibility</span>: hidden;</span><br><span class="line">    <span class="attribute">-webkit-transform</span>: <span class="built_in">scaleX</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="attribute">-moz-transform</span>: <span class="built_in">scaleX</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="attribute">-ms-transform</span>: <span class="built_in">scaleX</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="attribute">-o-transform</span>: <span class="built_in">scaleX</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scaleX</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="attribute">transition-duration</span>: <span class="number">0.2s</span>;</span><br><span class="line">    <span class="attribute">transition-timing-function</span>: ease-in-out;</span><br><span class="line">    <span class="attribute">transition-delay</span>: <span class="number">0s</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
效果如图：<br><img src="/images/7.png" alt=""></li>
</ul>
<h1 id="修改点击效果"><a href="#修改点击效果" class="headerlink" title="修改点击效果"></a>修改点击效果</h1><p>参考自<a href="https://hasaik.com/posts/9c9b482b.html" target="_blank" rel="noopener">博客</a><br>首先在/themes/next/_config.yml添加选项：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">cursor_effect:</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">explosion</span>  <span class="comment">#explosion：爆炸 | love：浮出爱心 需要什么效果自己选</span></span><br></pre></td></tr></table></figure>
<p>在/themes/next/layout/_custom/custom.swig ，添加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% if theme.cursor_effect %&#125;</span><br><span class="line">  &#123;% if theme.cursor_effect.type &#x3D;&#x3D; &quot;fireworks&quot; %&#125;</span><br><span class="line">    &lt;script src&#x3D;&quot;&#x2F;js&#x2F;cursor&#x2F;fireworks.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">  &#123;% elseif theme.cursor_effect.type &#x3D;&#x3D; &quot;explosion&quot; %&#125;</span><br><span class="line">    &lt;canvas class&#x3D;&quot;fireworks&quot; style&#x3D;&quot;position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;&quot; &gt;&lt;&#x2F;canvas&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;&#x2F;&#x2F;cdn.bootcss.com&#x2F;animejs&#x2F;2.2.0&#x2F;anime.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;&#x2F;js&#x2F;cursor&#x2F;explosion.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">  &#123;% elseif theme.cursor_effect.type &#x3D;&#x3D; &quot;love&quot; %&#125;</span><br><span class="line">    &lt;script src&#x3D;&quot;&#x2F;js&#x2F;cursor&#x2F;love.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">  &#123;% elseif theme.cursor_effect.type &#x3D;&#x3D; &quot;text&quot; %&#125;</span><br><span class="line">    &lt;script src&#x3D;&quot;&#x2F;js&#x2F;cursor&#x2F;text.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<p>如果没有这个文件夹和文件需要自己手动创建，同时在 /themes/next/layout/_layout.swig 中引入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% include &#39;_custom&#x2F;custom.swig&#39; %&#125;</span><br></pre></td></tr></table></figure>
<p>然后将这两个js文件复制到/themes/next/source/js/cursor/（没有的话手动创建）</p>
<p>explosion.min.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;<span class="function"><span class="keyword">function</span> <span class="title">updateCoords</span>(<span class="params">e</span>)</span>&#123;pointerX=(e.clientX||e.touches[<span class="number">0</span>].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[<span class="number">0</span>].clientY-canvasEl.getBoundingClientRect().top&#125;<span class="function"><span class="keyword">function</span> <span class="title">setParticuleDirection</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">var</span> t=anime.random(<span class="number">0</span>,<span class="number">360</span>)*<span class="built_in">Math</span>.PI/<span class="number">180</span>,a=anime.random(<span class="number">50</span>,<span class="number">180</span>),n=[<span class="number">-1</span>,<span class="number">1</span>][anime.random(<span class="number">0</span>,<span class="number">1</span>)]*a;<span class="keyword">return</span>&#123;<span class="attr">x</span>:e.x+n*<span class="built_in">Math</span>.cos(t),<span class="attr">y</span>:e.y+n*<span class="built_in">Math</span>.sin(t)&#125;&#125;<span class="function"><span class="keyword">function</span> <span class="title">createParticule</span>(<span class="params">e,t</span>)</span>&#123;<span class="keyword">var</span> a=&#123;&#125;;<span class="keyword">return</span> a.x=e,a.y=t,a.color=colors[anime.random(<span class="number">0</span>,colors.length<span class="number">-1</span>)],a.radius=anime.random(<span class="number">16</span>,<span class="number">32</span>),a.endPos=setParticuleDirection(a),a.draw=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">Math</span>.PI,!<span class="number">0</span>),ctx.fillStyle=a.color,ctx.fill()&#125;,a&#125;<span class="function"><span class="keyword">function</span> <span class="title">createCircle</span>(<span class="params">e,t</span>)</span>&#123;<span class="keyword">var</span> a=&#123;&#125;;<span class="keyword">return</span> a.x=e,a.y=t,a.color=<span class="string">"#F00"</span>,a.radius=<span class="number">0.1</span>,a.alpha=<span class="number">0.5</span>,a.lineWidth=<span class="number">6</span>,a.draw=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">Math</span>.PI,!<span class="number">0</span>),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=<span class="number">1</span>&#125;,a&#125;<span class="function"><span class="keyword">function</span> <span class="title">renderParticule</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">for</span>(<span class="keyword">var</span> t=<span class="number">0</span>;t&lt;e.animatables.length;t++)&#123;e.animatables[t].target.draw()&#125;&#125;<span class="function"><span class="keyword">function</span> <span class="title">animateParticules</span>(<span class="params">e,t</span>)</span>&#123;<span class="keyword">for</span>(<span class="keyword">var</span> a=createCircle(e,t),n=[],i=<span class="number">0</span>;i&lt;numberOfParticules;i++)&#123;n.push(createParticule(e,t))&#125;anime.timeline().add(&#123;<span class="attr">targets</span>:n,<span class="attr">x</span>:<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">return</span> e.endPos.x&#125;,<span class="attr">y</span>:<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">return</span> e.endPos.y&#125;,<span class="attr">radius</span>:<span class="number">0.1</span>,<span class="attr">duration</span>:anime.random(<span class="number">1200</span>,<span class="number">1800</span>),<span class="attr">easing</span>:<span class="string">"easeOutExpo"</span>,<span class="attr">update</span>:renderParticule&#125;).add(&#123;<span class="attr">targets</span>:a,<span class="attr">radius</span>:anime.random(<span class="number">80</span>,<span class="number">160</span>),<span class="attr">lineWidth</span>:<span class="number">0</span>,<span class="attr">alpha</span>:&#123;<span class="attr">value</span>:<span class="number">0</span>,<span class="attr">easing</span>:<span class="string">"linear"</span>,<span class="attr">duration</span>:anime.random(<span class="number">600</span>,<span class="number">800</span>)&#125;,<span class="attr">duration</span>:anime.random(<span class="number">1200</span>,<span class="number">1800</span>),<span class="attr">easing</span>:<span class="string">"easeOutExpo"</span>,<span class="attr">update</span>:renderParticule,<span class="attr">offset</span>:<span class="number">0</span>&#125;)&#125;<span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">e,t</span>)</span>&#123;<span class="keyword">var</span> a;<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">var</span> n=<span class="keyword">this</span>,i=<span class="built_in">arguments</span>;clearTimeout(a),a=setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;e.apply(n,i)&#125;,t)&#125;&#125;<span class="keyword">var</span> canvasEl=<span class="built_in">document</span>.querySelector(<span class="string">".fireworks"</span>);<span class="keyword">if</span>(canvasEl)&#123;<span class="keyword">var</span> ctx=canvasEl.getContext(<span class="string">"2d"</span>),numberOfParticules=<span class="number">30</span>,pointerX=<span class="number">0</span>,pointerY=<span class="number">0</span>,tap=<span class="string">"mousedown"</span>,colors=[<span class="string">"#FF1461"</span>,<span class="string">"#18FF92"</span>,<span class="string">"#5A87FF"</span>,<span class="string">"#FBF38C"</span>],setCanvasSize=debounce(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;canvasEl.width=<span class="number">2</span>*<span class="built_in">window</span>.innerWidth,canvasEl.height=<span class="number">2</span>*<span class="built_in">window</span>.innerHeight,canvasEl.style.width=<span class="built_in">window</span>.innerWidth+<span class="string">"px"</span>,canvasEl.style.height=<span class="built_in">window</span>.innerHeight+<span class="string">"px"</span>,canvasEl.getContext(<span class="string">"2d"</span>).scale(<span class="number">2</span>,<span class="number">2</span>)&#125;,<span class="number">500</span>),render=anime(&#123;<span class="attr">duration</span>:<span class="number">1</span>/<span class="number">0</span>,<span class="attr">update</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;ctx.clearRect(<span class="number">0</span>,<span class="number">0</span>,canvasEl.width,canvasEl.height)&#125;&#125;);<span class="built_in">document</span>.addEventListener(tap,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;<span class="string">"sidebar"</span>!==e.target.id&amp;&amp;<span class="string">"toggle-sidebar"</span>!==e.target.id&amp;&amp;<span class="string">"A"</span>!==e.target.nodeName&amp;&amp;<span class="string">"IMG"</span>!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))&#125;,!<span class="number">1</span>),setCanvasSize(),<span class="built_in">window</span>.addEventListener(<span class="string">"resize"</span>,setCanvasSize,!<span class="number">1</span>)&#125;<span class="string">"use strict"</span>;<span class="function"><span class="keyword">function</span> <span class="title">updateCoords</span>(<span class="params">e</span>)</span>&#123;pointerX=(e.clientX||e.touches[<span class="number">0</span>].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[<span class="number">0</span>].clientY-canvasEl.getBoundingClientRect().top&#125;<span class="function"><span class="keyword">function</span> <span class="title">setParticuleDirection</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">var</span> t=anime.random(<span class="number">0</span>,<span class="number">360</span>)*<span class="built_in">Math</span>.PI/<span class="number">180</span>,a=anime.random(<span class="number">50</span>,<span class="number">180</span>),n=[<span class="number">-1</span>,<span class="number">1</span>][anime.random(<span class="number">0</span>,<span class="number">1</span>)]*a;<span class="keyword">return</span>&#123;<span class="attr">x</span>:e.x+n*<span class="built_in">Math</span>.cos(t),<span class="attr">y</span>:e.y+n*<span class="built_in">Math</span>.sin(t)&#125;&#125;<span class="function"><span class="keyword">function</span> <span class="title">createParticule</span>(<span class="params">e,t</span>)</span>&#123;<span class="keyword">var</span> a=&#123;&#125;;<span class="keyword">return</span> a.x=e,a.y=t,a.color=colors[anime.random(<span class="number">0</span>,colors.length<span class="number">-1</span>)],a.radius=anime.random(<span class="number">16</span>,<span class="number">32</span>),a.endPos=setParticuleDirection(a),a.draw=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">Math</span>.PI,!<span class="number">0</span>),ctx.fillStyle=a.color,ctx.fill()&#125;,a&#125;<span class="function"><span class="keyword">function</span> <span class="title">createCircle</span>(<span class="params">e,t</span>)</span>&#123;<span class="keyword">var</span> a=&#123;&#125;;<span class="keyword">return</span> a.x=e,a.y=t,a.color=<span class="string">"#F00"</span>,a.radius=<span class="number">0.1</span>,a.alpha=<span class="number">0.5</span>,a.lineWidth=<span class="number">6</span>,a.draw=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">Math</span>.PI,!<span class="number">0</span>),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=<span class="number">1</span>&#125;,a&#125;<span class="function"><span class="keyword">function</span> <span class="title">renderParticule</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">for</span>(<span class="keyword">var</span> t=<span class="number">0</span>;t&lt;e.animatables.length;t++)&#123;e.animatables[t].target.draw()&#125;&#125;<span class="function"><span class="keyword">function</span> <span class="title">animateParticules</span>(<span class="params">e,t</span>)</span>&#123;<span class="keyword">for</span>(<span class="keyword">var</span> a=createCircle(e,t),n=[],i=<span class="number">0</span>;i&lt;numberOfParticules;i++)&#123;n.push(createParticule(e,t))&#125;anime.timeline().add(&#123;<span class="attr">targets</span>:n,<span class="attr">x</span>:<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">return</span> e.endPos.x&#125;,<span class="attr">y</span>:<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">return</span> e.endPos.y&#125;,<span class="attr">radius</span>:<span class="number">0.1</span>,<span class="attr">duration</span>:anime.random(<span class="number">1200</span>,<span class="number">1800</span>),<span class="attr">easing</span>:<span class="string">"easeOutExpo"</span>,<span class="attr">update</span>:renderParticule&#125;).add(&#123;<span class="attr">targets</span>:a,<span class="attr">radius</span>:anime.random(<span class="number">80</span>,<span class="number">160</span>),<span class="attr">lineWidth</span>:<span class="number">0</span>,<span class="attr">alpha</span>:&#123;<span class="attr">value</span>:<span class="number">0</span>,<span class="attr">easing</span>:<span class="string">"linear"</span>,<span class="attr">duration</span>:anime.random(<span class="number">600</span>,<span class="number">800</span>)&#125;,<span class="attr">duration</span>:anime.random(<span class="number">1200</span>,<span class="number">1800</span>),<span class="attr">easing</span>:<span class="string">"easeOutExpo"</span>,<span class="attr">update</span>:renderParticule,<span class="attr">offset</span>:<span class="number">0</span>&#125;)&#125;<span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">e,t</span>)</span>&#123;<span class="keyword">var</span> a;<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">var</span> n=<span class="keyword">this</span>,i=<span class="built_in">arguments</span>;clearTimeout(a),a=setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;e.apply(n,i)&#125;,t)&#125;&#125;<span class="keyword">var</span> canvasEl=<span class="built_in">document</span>.querySelector(<span class="string">".fireworks"</span>);<span class="keyword">if</span>(canvasEl)&#123;<span class="keyword">var</span> ctx=canvasEl.getContext(<span class="string">"2d"</span>),numberOfParticules=<span class="number">30</span>,pointerX=<span class="number">0</span>,pointerY=<span class="number">0</span>,tap=<span class="string">"mousedown"</span>,colors=[<span class="string">"#FF1461"</span>,<span class="string">"#18FF92"</span>,<span class="string">"#5A87FF"</span>,<span class="string">"#FBF38C"</span>],setCanvasSize=debounce(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;canvasEl.width=<span class="number">2</span>*<span class="built_in">window</span>.innerWidth,canvasEl.height=<span class="number">2</span>*<span class="built_in">window</span>.innerHeight,canvasEl.style.width=<span class="built_in">window</span>.innerWidth+<span class="string">"px"</span>,canvasEl.style.height=<span class="built_in">window</span>.innerHeight+<span class="string">"px"</span>,canvasEl.getContext(<span class="string">"2d"</span>).scale(<span class="number">2</span>,<span class="number">2</span>)&#125;,<span class="number">500</span>),render=anime(&#123;<span class="attr">duration</span>:<span class="number">1</span>/<span class="number">0</span>,<span class="attr">update</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;ctx.clearRect(<span class="number">0</span>,<span class="number">0</span>,canvasEl.width,canvasEl.height)&#125;&#125;);<span class="built_in">document</span>.addEventListener(tap,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;<span class="string">"sidebar"</span>!==e.target.id&amp;&amp;<span class="string">"toggle-sidebar"</span>!==e.target.id&amp;&amp;<span class="string">"A"</span>!==e.target.nodeName&amp;&amp;<span class="string">"IMG"</span>!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))&#125;,!<span class="number">1</span>),setCanvasSize(),<span class="built_in">window</span>.addEventListener(<span class="string">"resize"</span>,setCanvasSize,!<span class="number">1</span>)&#125;;</span><br></pre></td></tr></table></figure>

<p>love.min.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params">e,t,a</span>)</span>&#123;<span class="function"><span class="keyword">function</span> <span class="title">n</span>(<span class="params"></span>)</span>&#123;c(<span class="string">".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;"</span>),o(),r()&#125;<span class="function"><span class="keyword">function</span> <span class="title">r</span>(<span class="params"></span>)</span>&#123;<span class="keyword">for</span>(<span class="keyword">var</span> e=<span class="number">0</span>;e&lt;d.length;e++)d[e].alpha&lt;=<span class="number">0</span>?(t.body.removeChild(d[e].el),d.splice(e,<span class="number">1</span>)):(d[e].y--,d[e].scale+=<span class="number">.004</span>,d[e].alpha-=<span class="number">.013</span>,d[e].el.style.cssText=<span class="string">"left:"</span>+d[e].x+<span class="string">"px;top:"</span>+d[e].y+<span class="string">"px;opacity:"</span>+d[e].alpha+<span class="string">";transform:scale("</span>+d[e].scale+<span class="string">","</span>+d[e].scale+<span class="string">") rotate(45deg);background:"</span>+d[e].color+<span class="string">";z-index:99999"</span>);requestAnimationFrame(r)&#125;<span class="function"><span class="keyword">function</span> <span class="title">o</span>(<span class="params"></span>)</span>&#123;<span class="keyword">var</span> t=<span class="string">"function"</span>==<span class="keyword">typeof</span> e.onclick&amp;&amp;e.onclick;e.onclick=<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;t&amp;&amp;t(),i(e)&#125;&#125;<span class="function"><span class="keyword">function</span> <span class="title">i</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">var</span> a=t.createElement(<span class="string">"div"</span>);a.className=<span class="string">"heart"</span>,d.push(&#123;<span class="attr">el</span>:a,<span class="attr">x</span>:e.clientX<span class="number">-5</span>,<span class="attr">y</span>:e.clientY<span class="number">-5</span>,<span class="attr">scale</span>:<span class="number">1</span>,<span class="attr">alpha</span>:<span class="number">1</span>,<span class="attr">color</span>:s()&#125;),t.body.appendChild(a)&#125;<span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">var</span> a=t.createElement(<span class="string">"style"</span>);a.type=<span class="string">"text/css"</span>;<span class="keyword">try</span>&#123;a.appendChild(t.createTextNode(e))&#125;<span class="keyword">catch</span>(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName(<span class="string">"head"</span>)[<span class="number">0</span>].appendChild(a)&#125;<span class="function"><span class="keyword">function</span> <span class="title">s</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span><span class="string">"rgb("</span>+~~(<span class="number">255</span>*<span class="built_in">Math</span>.random())+<span class="string">","</span>+~~(<span class="number">255</span>*<span class="built_in">Math</span>.random())+<span class="string">","</span>+~~(<span class="number">255</span>*<span class="built_in">Math</span>.random())+<span class="string">")"</span>&#125;<span class="keyword">var</span> d=[];e.requestAnimationFrame=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;setTimeout(e,<span class="number">1e3</span>/<span class="number">60</span>)&#125;&#125;(),n()&#125;(<span class="built_in">window</span>,<span class="built_in">document</span>);</span><br></pre></td></tr></table></figure>
<p>保存编译即可，enjoy it~</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>美化</tag>
        <tag>hexo</tag>
        <tag>点击效果</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql远程连接</title>
    <url>/2020/07/14/mysql%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/</url>
    <content><![CDATA[<p>今天记录一个困扰了我很久，每次都是莫名其妙发生又莫名其妙解决的问题：当使用navicat连接远程数据库时无法连接（错误代码2003或其他）问题的简单分析和解决方案。</p>
<a id="more"></a>
<p>当远程连接mysql数据库连接失败时，一般分为几种情况：</p>
<ul>
<li>未授予远程账号使用root连接的权限</li>
<li>在配置文件中限定了只有本地IP可以连接</li>
<li>Linux系统防火墙对3306端口（或其他指定端口）进行了限制<h2 id="授予远程账号访问权限"><a href="#授予远程账号访问权限" class="headerlink" title="授予远程账号访问权限"></a>授予远程账号访问权限</h2>在终端登陆mysql，选择mysql数据库之后查询user表中的host信息<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; use mysql;</span><br><span class="line">Database changed</span><br><span class="line">mysql&gt; select user,password,host from user;</span><br><span class="line">+------+-------------------------------------------+----------------+</span><br><span class="line">| user | password                                  | host           |</span><br><span class="line">+------+-------------------------------------------+----------------+</span><br><span class="line">| root | *81F5E21E35407D884A6CD4A731AEBFB6AF209E1B | localhost      |</span><br><span class="line">| root | *81F5E21E35407D884A6CD4A731AEBFB6AF209E1B | 127.0.0.1      |</span><br><span class="line">| root | *81F5E21E35407D884A6CD4A731AEBFB6AF209E1B | ::1            |</span><br><span class="line">+------+-------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>
可以看到当用户为root时，只有本地账户可以进行连接，我们只需要把localhost修改为%即可。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">update user set host&#x3D;&quot;%&quot; where host&#x3D;&quot;localhost&quot;;</span><br></pre></td></tr></table></figure>
<h2 id="解除配置文件只允许本地连接的限制"><a href="#解除配置文件只允许本地连接的限制" class="headerlink" title="解除配置文件只允许本地连接的限制"></a>解除配置文件只允许本地连接的限制</h2>找到my.conf(一般在/etc/my.conf或/etc/mysql/my.conf，版本不同会造成差异)，将下面的代码注释掉。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bind-address &#x3D; 127.0.0.1</span><br></pre></td></tr></table></figure>
<h2 id="解除linux对端口的限制"><a href="#解除linux对端口的限制" class="headerlink" title="解除linux对端口的限制"></a>解除linux对端口的限制</h2>前面两个问题其实大部分时候都会注意到，这最后一个可真是困扰了我好久<br><del>（菜）</del>。</li>
</ul>
<p>首先是iptables，经过查阅资料我发现tables本身就是linux内核的一部分所以无法删除<br><del>（我还天真的想把它删了）</del><br>所以我们要做的是直接解除iptables对所有端口的限制：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables -P INPUT ACCEPT</span><br><span class="line">iptables -P OUTPUT ACCEPT</span><br><span class="line">iptables -P FORWARD ACCEPT</span><br><span class="line">iptables -F</span><br></pre></td></tr></table></figure>
<p>然后如果开启了ufw，也需要关闭：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo ufw disable</span><br></pre></td></tr></table></figure>

<p>最后不要忘记重启MySQL服务。</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>Navicat</tag>
      </tags>
  </entry>
  <entry>
    <title>一和零</title>
    <url>/2020/09/12/%E4%B8%80%E5%92%8C%E9%9B%B6/</url>
    <content><![CDATA[<h2 id="LeetCode-474"><a href="#LeetCode-474" class="headerlink" title="LeetCode #474"></a>LeetCode #474</h2><a id="more"></a>
<p><a href="https://leetcode-cn.com/problems/ones-and-zeroes/" target="_blank" rel="noopener">链接</a><br>三维动规，可以循环判断每一个包含的字符串从而进行空间优化，注意在动规的时候需要从后往前找（即从m-&gt;cnt1,n-&gt;cnt2，从前往后会影响之前的状态<del>改了好久，菜啊</del>）动态规划可太快乐了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">200</span>][<span class="number">200</span>];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMaxForm</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; strs.<span class="built_in">size</span>() ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> cnt1 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> cnt2 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j  = <span class="number">0</span> ; j &lt; strs[i].<span class="built_in">size</span>() ; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(strs[i][j] == <span class="string">'0'</span>)</span><br><span class="line">                    cnt1++;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    cnt2++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = m ; j &gt;= cnt1 ;j --)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = n ; k &gt;= cnt2 ; k --)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[j][k] = <span class="built_in">max</span>(dp[j][k],dp[j-cnt1][k-cnt2]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的层平均值</title>
    <url>/2020/09/12/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%B9%B3%E5%9D%87%E5%80%BC/</url>
    <content><![CDATA[<h2 id="Leetcode-637"><a href="#Leetcode-637" class="headerlink" title="Leetcode#637"></a>Leetcode#637</h2><a id="more"></a>
<p>水题，直接一个裸的广搜，按层遍历树的每一层即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="built_in">queue</span>&lt;TreeNode*&gt;qu;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;ans;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">averageOfLevels</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        qu.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!qu.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> cnt = qu.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">double</span> temp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; cnt ;i ++)</span><br><span class="line">            &#123;</span><br><span class="line">                temp += qu.front() -&gt; val;</span><br><span class="line">                <span class="keyword">if</span>(qu.front() -&gt; left != <span class="literal">NULL</span>)</span><br><span class="line">                    qu.push(qu.front() -&gt; left);</span><br><span class="line">                <span class="keyword">if</span>(qu.front() -&gt; right != <span class="literal">NULL</span>)</span><br><span class="line">                    qu.push(qu.front() -&gt; right);</span><br><span class="line">                qu.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(temp/cnt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><del>尝试用auto声明居然出现了误差，不知道为什么会自动成int类型，果然还是菜啊</del></p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的中序遍历</title>
    <url>/2020/09/14/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h2 id="LeetCode-94"><a href="#LeetCode-94" class="headerlink" title="LeetCode#94"></a>LeetCode#94</h2><a id="more"></a>
<p><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">题目链接</a></p>
<p>二叉树的中序遍历，首先我们来看一下二叉树的前序（VLR）、中序（LDR）、后序（LRD）遍历的定义:</p>
<p>前序遍历：先访问根节点，再遍历左子树，最后遍历右子树</p>
<p>中序遍历：先遍历左子树，再访问根节点，最后遍历右子树</p>
<p>后序遍历：先遍历左子树，再访问右子树，最后访问根节点</p>
<p>有了三种遍历的定义，我们在举个例子具体看一下：<br><img src="/images/erchashu.png" alt=""></p>
<p>先序遍历：123564</p>
<p>中序遍历：153624</p>
<p>后续遍历：563421</p>
<p>结合这个具体的例子是不是就理解了呢？</p>
<p>理解了中序遍历，代码就很好理解了，先判断当前节点是否右左子树，如果有则继续遍历，没有则直接将当前节点存入答案，最后再遍历右子树。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;ans;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span>(node -&gt;left != <span class="literal">nullptr</span>)</span><br><span class="line">            dfs(node -&gt; left);</span><br><span class="line">        ans.push_back(node -&gt; val);</span><br><span class="line">        <span class="keyword">if</span>(node -&gt; right != <span class="literal">nullptr</span>)</span><br><span class="line">            dfs(node -&gt; right); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>全排列</title>
    <url>/2020/09/18/%E5%85%A8%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<h2 id="LeetCode-46、-47"><a href="#LeetCode-46、-47" class="headerlink" title="LeetCode#46、#47"></a>LeetCode#46、#47</h2><a id="more"></a>
<p><a href="https://leetcode-cn.com/problems/permutations/" target="_blank" rel="noopener">#46</a><br><a href="https://leetcode-cn.com/problems/permutations-ii/" target="_blank" rel="noopener">#47</a><br>今天的每日一题是一个全排列的升级版，突然发现忘记了全排列怎么写..<del>（菜）</del><br>就顺便做了46题，裸的全排列，记录一下思路。</p>
<p>先看裸的全排列，我们直接想到的就是直接分别以每一个数为第一个数，遍历所有的可能性，但是因为我们不知道数组中有多少个数，所以我们就没法确定要写多少层的循环<del>也不是能写</del>所以这时候我们就需要用到深搜/广搜的想法，通过递归和回溯的方法来进行基本的遍历。</p>
<p>为了避免重复，我们可以写一个标记数组来记录在当前的递归中这个数是否已经使用过，然后再回溯的时候再取消标记，当然对于这种简单的递归我们也可以省去一点空间复杂度，直接当遍历到第pos个数的时候和当前循环中的第i个数进行交换，以达到全排列的效果。其原理是我们可以把从0-pos的数认为是已经选择过的，pos+1-size()-1即为未选择过的</p>
<p>#46代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;&amp;ans,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;nums,<span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos == nums.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            ans.push_back(nums);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = pos ; i &lt; nums.<span class="built_in">size</span>() ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            swap(nums[i],nums[pos]);</span><br><span class="line">            dfs(ans,nums,pos+<span class="number">1</span>);</span><br><span class="line">            swap(nums[i],nums[pos]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">permute</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;ans;</span><br><span class="line">        dfs(ans,nums,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>#47和#46的区别就是给定的数组中可能存在相同的数字，这样就导致我们如果照常进行全排列遍历就有可能出现重复的情况，我用的是一个比较笨的方法，直接使用set容器来进行去重（set毕竟是基于红黑树的操作，速度还是很快<del>（慢）</del><br>的，这样的结果就是时间复杂度和空间复杂度都很高，但是方便。还有一种方法，先使用sort对给定的数组进行排序，这样在递归回溯过程中就可以进行判断，配合标记数组，时间复杂度会快很多，但是由于我没写明白所以…建议去看题解<del>(逃)</del></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;flag,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;&amp;ans,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;nums,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;temp,<span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos == nums.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            ans.push_back(temp);</span><br><span class="line">            <span class="keyword">return</span>;        </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.<span class="built_in">size</span>() ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!flag[i])</span><br><span class="line">&#123;            flag[i] = <span class="number">1</span>;</span><br><span class="line">            temp.push_back(nums[i]);</span><br><span class="line">            dfs(flag,ans,nums,temp,pos+<span class="number">1</span>);</span><br><span class="line">            flag[i] = <span class="number">0</span>;</span><br><span class="line">            temp.pop_back();&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">permuteUnique</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;ans;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;flag(nums.<span class="built_in">size</span>(),<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;temp;</span><br><span class="line">        dfs(flag,ans,nums,temp,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;s;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;::iterator it;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;ansr;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i  = <span class="number">0</span> ; i &lt; ans.<span class="built_in">size</span>() ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            s.insert(ans[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(it = s.<span class="built_in">begin</span>() ; it != s.<span class="built_in">end</span>() ;it++)</span><br><span class="line">        &#123;</span><br><span class="line">            ansr.push_back(*it);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ansr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>深搜</tag>
      </tags>
  </entry>
  <entry>
    <title>子集</title>
    <url>/2020/09/20/%E5%AD%90%E9%9B%86/</url>
    <content><![CDATA[<h2 id="LeetCode-78"><a href="#LeetCode-78" class="headerlink" title="LeetCode#78"></a>LeetCode#78</h2><a id="more"></a>
<p><a href="https://leetcode-cn.com/problems/subsets/submissions/" target="_blank" rel="noopener">题目链接</a><br>一道基础的回溯题<del>(这几天怎么都是回溯)</del>与全排列问题类似，区别是需要在每一次遍历的时候分别保存结果，而不是当找到nums.size()的时候再保存结果<br>附代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; ans,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;temp,<span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos == nums.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = pos ; i &lt; nums.<span class="built_in">size</span>() ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            temp.push_back(nums[i]);</span><br><span class="line">            ans.push_back(temp);</span><br><span class="line">            dfs(nums,ans,temp,i+<span class="number">1</span>);</span><br><span class="line">            temp.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">subsets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;ans;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;temp;</span><br><span class="line">        ans.push_back(temp);</span><br><span class="line">        dfs(nums,ans,temp,<span class="number">0</span>);   </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>深搜</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>左叶子子之和</title>
    <url>/2020/09/19/%E5%B7%A6%E5%8F%B6%E5%AD%90%E5%AD%90%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h2 id="LeetCode-404"><a href="#LeetCode-404" class="headerlink" title="LeetCode#404"></a>LeetCode#404</h2><a id="more"></a>
<p><a href="https://leetcode-cn.com/problems/sum-of-left-leaves/" target="_blank" rel="noopener">题目链接</a><br>深搜遍历每个节点，判断一下是否为左叶子节点即可，没啥好说的，我是用一个标记flag来记录是否为左节点的，如果不是则直接继续遍历<br>附代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* node,<span class="keyword">long</span> <span class="keyword">long</span> &amp;ans,<span class="keyword">int</span> flag)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(node -&gt; left == <span class="literal">nullptr</span> &amp;&amp;  node -&gt; right == <span class="literal">nullptr</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    ans+=node -&gt; val;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">if</span>(node -&gt; left != <span class="literal">nullptr</span>)</span><br><span class="line">                dfs(node-&gt;left,ans,<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(node -&gt; right != <span class="literal">nullptr</span>)</span><br><span class="line">                dfs(node-&gt;right,ans,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(node -&gt; left != <span class="literal">nullptr</span>)</span><br><span class="line">                dfs(node-&gt;left,ans,<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(node -&gt; right != <span class="literal">nullptr</span>)</span><br><span class="line">                dfs(node-&gt;right,ans,<span class="number">0</span>);            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        dfs(root,ans,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>深搜</tag>
      </tags>
  </entry>
  <entry>
    <title>单词搜索</title>
    <url>/2020/09/13/%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<h2 id="LeetCode-79"><a href="#LeetCode-79" class="headerlink" title="LeetCode#79"></a>LeetCode#79</h2><a id="more"></a>
<p><a href="https://leetcode-cn.com/problems/word-search/submissions/" target="_blank" rel="noopener">题目链接</a><br>一道看似简单深搜回溯,需要注意在回溯过程中判断结束回溯的条件(图的边界,字符串长度)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> flag[<span class="number">205</span>][<span class="number">205</span>];</span><br><span class="line">    <span class="keyword">bool</span> ans = <span class="literal">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="built_in">string</span>&amp; <span class="keyword">word</span>,<span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function">    </span>&#123;   </span><br><span class="line">        <span class="comment">//cout &lt;&lt; x &lt;&lt; y &lt;&lt; word &lt;&lt; pos &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">0</span> </span><br><span class="line">        || x &gt;= board.<span class="built_in">size</span>() </span><br><span class="line">        || y &lt; <span class="number">0</span> </span><br><span class="line">        || y &gt;= board[<span class="number">0</span>].<span class="built_in">size</span>() </span><br><span class="line">        || board[x][y] != <span class="keyword">word</span>[pos] </span><br><span class="line">        || flag[x][y] ==<span class="number">1</span></span><br><span class="line">        || ans == <span class="literal">true</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; board[x][y] &lt;&lt; " " &lt;&lt; x &lt;&lt; " " &lt;&lt; y  &lt;&lt; " "  &lt;&lt; pos &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">if</span>(flag[x][y] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(pos == <span class="keyword">word</span>.<span class="built_in">size</span>() - <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ans = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            flag[x][y] = <span class="number">1</span>;</span><br><span class="line">            dfs(board,x+<span class="number">1</span>,y,<span class="keyword">word</span>,pos+<span class="number">1</span>);</span><br><span class="line">            dfs(board,x<span class="number">-1</span>,y,<span class="keyword">word</span>,pos+<span class="number">1</span>);</span><br><span class="line">            dfs(board,x,y+<span class="number">1</span>,<span class="keyword">word</span>,pos+<span class="number">1</span>);</span><br><span class="line">            dfs(board,x,y<span class="number">-1</span>,<span class="keyword">word</span>,pos+<span class="number">1</span>);</span><br><span class="line">            flag[x][y] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span> <span class="keyword">word</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; board.<span class="built_in">size</span>() ; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].<span class="built_in">size</span>() ; j++)</span><br><span class="line">                dfs(board,i,j,<span class="keyword">word</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>传递形参时,会在栈内重新构建数组,传引用则不会(或使用全局数组),二者在空间和时间复杂度上都差很多</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>深搜</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>把二叉搜索树转换为累加树</title>
    <url>/2020/09/21/%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91/</url>
    <content><![CDATA[<h2 id="Leetcode-538"><a href="#Leetcode-538" class="headerlink" title="Leetcode#538"></a>Leetcode#538</h2><a id="more"></a>
<p><a href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/" target="_blank" rel="noopener">题目链接</a><br>刚开始看题的时候没有注意是二叉搜索树，所以只想到了用最傻x的方法：先将整个二叉树遍历一遍，取得所有val然后进行排序，再遍历二叉树分别，配合已经排序好的val数组进行循环累加。这样也是可以过的，但是不管时间复杂度还是空间复杂度都很高。<br>附一个不需要注释就能看懂的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* node,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        nums.push_back(node -&gt; val);</span><br><span class="line">        <span class="keyword">if</span>(node -&gt; left != <span class="literal">nullptr</span>)</span><br><span class="line">            dfs(node -&gt; left,nums);</span><br><span class="line">        <span class="keyword">if</span>(node -&gt; right != <span class="literal">nullptr</span>)</span><br><span class="line">           dfs(node -&gt; right,nums);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(TreeNode* node,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.<span class="built_in">size</span>() ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( nums[i] &gt; node -&gt; val)</span><br><span class="line">                sum+=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        node -&gt; val += sum;</span><br><span class="line">        <span class="keyword">if</span>(node -&gt; left != <span class="literal">nullptr</span>)</span><br><span class="line">            dfs1(node -&gt; left,nums);</span><br><span class="line">        <span class="keyword">if</span>(node -&gt; right != <span class="literal">nullptr</span>)</span><br><span class="line">           dfs1(node -&gt; right,nums);   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">convertBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;nums;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        dfs(root,nums);</span><br><span class="line">        sort(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        dfs1(root,nums);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>因为是二叉搜索树，所以已经排好了顺序，我们只需要通过反向中序遍历，就可以实现从大到小的累加和排序，只需要一遍就可以实现效果</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">convertBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            convertBST(root-&gt;right);</span><br><span class="line">            sum += root-&gt;val;</span><br><span class="line">            root-&gt;val = sum;</span><br><span class="line">            convertBST(root-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>搜索功能</title>
    <url>/2020/09/22/%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<p>一直觉得blog的搜索功能很有用<del>装x</del>，方便我们来查找自己曾经写过的东西，所以今天按照大佬的方法给博客加了个搜索的功能，操作很简单，有手就行<del>没有也行</del></p>
<a id="more"></a>
<p><a href="https://blog.csdn.net/lijing742180/article/details/87970909" target="_blank" rel="noopener">参考链接</a></p>
<ul>
<li>首先切换到博客目录下，安装hexo的搜索插件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure>
安装后会自动创建一个search.xml，我个人理解是相当于创建了索引（因为是纯静态页面嘛）</li>
<li>然后修改hexo的配置文件_config.yml（注意不是主题的），添加如下内容：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Search </span><br><span class="line">search:</span><br><span class="line">  path: .&#x2F;public&#x2F;search.xml &#x2F;&#x2F;索引的位置</span><br><span class="line">  field: post &#x2F;&#x2F;搜索的范围，默认post，也可以手动设置all、page等等</span><br><span class="line">  format: html &#x2F;&#x2F;搜索的类型</span><br><span class="line">  limit: 10000 &#x2F;&#x2F;限制搜索的条目数</span><br></pre></td></tr></table></figure></li>
<li>接下来只要配置好主题相关内容就可以了，因为我用的是next主题，默认就有搜索功能的支持，所以我只要选择打开这个功能就可以了。在next的_config.xml文件中搜索local_search，然后做如下修改：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">local_search:</span><br><span class="line">  enable: true &#x2F;&#x2F;开启搜索功能</span><br><span class="line">  trigger: auto</span><br><span class="line">  top_n_per_article: 1</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>本地搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>新博客的第一篇文章</title>
    <url>/2020/07/06/%E6%96%B0%E5%8D%9A%E5%AE%A2%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<p>折腾了一周时间终于搭好了基于hexo的个人博客，使用了next主题 <del>（主要是可以白嫖github的域名和静态页面）</del><br>接下来博客还有很多需要完善的地方<del>（以及美化（逃））</del></p>
<a id="more"></a>
<p><strong>预计功能有：</strong></p>
<ul>
<li>阅读量统计</li>
<li>评论区</li>
<li>以及美化 and so on…</li>
</ul>
<p>希望自己能坚持下来，将写博客这个好习惯保持下去</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>添加评论</title>
    <url>/2020/07/07/%E6%B7%BB%E5%8A%A0%E8%AF%84%E8%AE%BA/</url>
    <content><![CDATA[<p>我发现next主题真的是个好东西，什么东西都给我们写好了，添加很多组件都很方便。接下来记录一下如何添加讨论区。</p>
<a id="more"></a>
<p>hexo上可用的讨论区有很多：valine、来必力、disqus、facebookcomments等等，这里选择valine作为博客使用的主力评论系统。valine是完全基于静态页面的本地评论区，加载迅速而且上手简单，而且支持markdown（简直不要太爽）。</p>
<p>valine也是基于leancloud的服务，所以和添加阅读数量一样也需要先注册一个leancloud，并且在存储中新建一个comment类（可以参考我的<a href="https://nobilta.github.io/2020/07/07/%E6%B7%BB%E5%8A%A0%E9%98%85%E8%AF%BB%E6%AC%A1%E6%95%B0/">上一篇博客</a>，其他操作相同）然后在next主题的配置文件中对valine进行配置。<br><img src="/images/4.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enable:&#x2F;&#x2F;是否开启valine评论</span><br><span class="line">appid: &#x2F;&#x2F;你自己的id</span><br><span class="line">appkey: &#x2F;&#x2F;你自己的key</span><br><span class="line">notify: &#x2F;&#x2F;是否通过邮箱通知你</span><br><span class="line">verify: &#x2F;&#x2F;是否验证（反人类建议关闭）</span><br><span class="line">placeholder: &#x2F;&#x2F;评论区的默认标语</span><br><span class="line">avatar: &#x2F;&#x2F;头像</span><br><span class="line">guest_info: &#x2F;&#x2F;评论的人需要填什么信息</span><br><span class="line">pageSize: &#x2F;&#x2F;每页几个评论</span><br><span class="line">language: &#x2F;&#x2F;语言</span><br><span class="line">visitor: &#x2F;&#x2F;文章阅读稳定性相关（不太懂）</span><br><span class="line">comment_count:&#x2F;&#x2F;评论计数</span><br><span class="line">recordIP: &#x2F;&#x2F;记录ip（别人看不到）</span><br><span class="line">serverURLs: &#x2F;&#x2F;如果他没填写昵称的话显示的东西</span><br></pre></td></tr></table></figure>
<p>开启评论之后，会在每个页面都显示评论，如果我们不想让它显示评论呢？（比如标签页和分类页）</p>
<p>我们就需要在这篇文章的头部部分加上：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">comment:false</span><br></pre></td></tr></table></figure>
<p><img src="/images/5.png" alt=""><br>作为一个强迫症，在添加评论数后，头部没有做到全部汉化，评论数还显示valine是我难以忍受的，这是因为next默认支持多种评论区，所以默认显示当前开启了何种评论所以我们可以自己编译一下。在next文件夹中找到language文件夹，找到post部分，按照上面的样式添加一条：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">commet.valine :评论数&#x2F;&#x2F;注意一定要有个空格</span><br></pre></td></tr></table></figure>
<p>效果如图：<br><img src="/images/6.png" alt=""></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>评论</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>柱状图中最大的矩形</title>
    <url>/2020/09/14/%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2/</url>
    <content><![CDATA[<h2 id="LeetCode-84"><a href="#LeetCode-84" class="headerlink" title="LeetCode#84"></a>LeetCode#84</h2><a id="more"></a>
<p><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener">题目链接</a></p>
<p>单调栈顾名思义，是单调的栈<br><del>（这不废话吗）</del>，即栈内的所有元素都为单调递增或递减的。单调栈看似简单，但是在实际应用中可以通过O(n)的时间复杂度来完成很多复杂的遍历。</p>
<p>以这道题来说，看到题目后我第一想法是直接暴力遍历，挨个遍历每一个矩形，然后分别往左右进行扩展，找到相邻的所有高度大于当前矩形的矩形，进而求出大矩形的宽度，但是这样的时间复杂度会达到一个爆炸的状态（尤其数据比较恶心且数据量很大的时候），极有可能会t。</p>
<p>这时候就轮到单调栈来登场了，先放上我学习单调栈用到的<a href="https://blog.csdn.net/Zolewit/article/details/88863970" target="_blank" rel="noopener">链接</a>，我们还是分别以每一个矩形的高度作为高，但是这次我们只需要遍历一次就可以得到所有高度的最大矩形。原文作者已经讲的很清晰了，我在此基础上再补充一些我在自己做这道题过程中的一点理解。</p>
<p>先附上自己写的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">       heights.push_back(<span class="number">0</span>);</span><br><span class="line">       <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;sta;</span><br><span class="line">       <span class="keyword">int</span> maxnum = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; heights.<span class="built_in">size</span>() ; i++)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">while</span>(!sta.empty() &amp;&amp; heights[i] &lt; heights[sta.top()])</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">int</span> top = sta.top();</span><br><span class="line">               sta.pop();</span><br><span class="line">               <span class="keyword">if</span>(sta.empty())</span><br><span class="line">                maxnum = <span class="built_in">max</span>(maxnum,heights[top]*i);</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">               maxnum = <span class="built_in">max</span>(maxnum,heights[top] * (i - (sta.top() + <span class="number">1</span>)));</span><br><span class="line">           &#125;</span><br><span class="line">           sta.push(i);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> maxnum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>在计算宽度的时候为什么要区分每一个矩形的左右边沿？因为heights数组是从0开始的，且每一个矩形是有自身的宽度的，不能简单的看作一个点或者一条线，而在计算宽度的时候这些都是要考虑进去的，比如第三个矩形到第一个矩形实际宽度应该是3，而如果简单的用矩形的编号相减（2-0）很明显是错误的。</p>
</li>
<li><p>为什么要给heights数组的结尾推入一个0？我个人理解是求得的每个高度所构成的最大矩形面积实际是在栈顶元素弹出时进行求解的，所以需要弹出每一个栈内元素之后才相当于遍历完成，否则会缺少条件。</p>
</li>
<li><p>结合代码和上一条分析来看，也就能一下明白了为什么在计算面积时使用的高度为heights[top]而不是heights[i]了。换言之就是当遇到比栈顶小的height，就是栈顶这个高度的矩形的宽不能再往右扩了，而因为我们采用的单调栈保证了栈内元素的单调递增，所以相当于也限定了这个高度的左侧宽度到哪里<br><del>（我在这卡了好久想不明白，还是菜啊）</del></p>
</li>
</ul>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>添加阅读次数</title>
    <url>/2020/07/07/%E6%B7%BB%E5%8A%A0%E9%98%85%E8%AF%BB%E6%AC%A1%E6%95%B0/</url>
    <content><![CDATA[<p>博客添加阅读次数是一件很有用<del>装逼</del>的事情，以下均是基于GitHub page+hexo+next主题进行配置。</p>
<a id="more"></a>
<p>首先需要用到leancloud的服务，首先我们需要注册一个<a href="https://leancloud.cn/dashboard/login.html" target="_blank" rel="noopener">leancloud</a>，登陆后创建一个开发版的应用,这里面应用名称可随意填写 <del>（反正也可以改）</del>。<br><img src="/images/1.png" alt=""></p>
<p>然后在存储中创建一个名为Conter的新class（注意权限都为所有用户）<br><img src="/images/2.png" alt=""></p>
<p>然后在设置-安全中心-Web安全域名中填入自己博客的域名，以防被ban导致无法使用，然后进入应用Keys，将AppID和AppKey都复制下来一会会用到。</p>
<p>接下来是本地的配置，由于next默认是支持这个功能的，所以我们只需要开启就好了，在next主题根目录下找到_config.yml文件，按照如图所示进行修改（appid和keyid填你自己的）<br><img src="/images/3.png" alt=""><br>注意一定要把security改为false，否则会提示你计数不可用（当然也有其他办法只不过我不太会233）<br>编译，上传，发现已经搞好了！</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>阅读次数</tag>
        <tag>leancloud</tag>
      </tags>
  </entry>
  <entry>
    <title>监控二叉树</title>
    <url>/2020/09/22/%E7%9B%91%E6%8E%A7%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h2 id="LeetCode-968"><a href="#LeetCode-968" class="headerlink" title="LeetCode#968"></a>LeetCode#968</h2><a id="more"></a>
<p><a href="https://leetcode-cn.com/problems/binary-tree-cameras/" target="_blank" rel="noopener">题目链接</a></p>
<p>一道在树上的dp问题，因为是树所以我们比较能简单的想到使用递归回溯的方法。（不停的遍历子节点，所以是递归回溯）而回溯的时候需要几种情况的参数，来辅助自己选择最小值。</p>
<p>三种情况：</p>
<ul>
<li>a：统计了整个树需要的摄像头数量，并且当前节点上安装了摄像头</li>
<li>b: 统计了整个树需要的最少摄像头数量，并且当前节点可以选择不安装摄像头（意思是如果它的两个子结点中有一个安装了摄像头，当前节点就不需要安装了，需要具体考虑并取最小值，这是我们需要的最终结果）</li>
<li>c: 统计了不考虑当前节点需要的最少摄像头数量（即只考虑它的子树需要的摄像头数量）</li>
</ul>
<p>我们假设当前节点的左右节点返回的结果分别为la、lb、lc、ra、rb、rc<br>那么我们就有如下结论：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; lc+rc+1 &#x2F;&#x2F;左节点上不安装摄像头+右节点不安装摄像头+一个当前节点安装的摄像头</span><br><span class="line">b &#x3D; min(a,min(la+rb,lb+ra)) &#x2F;&#x2F;两种情况，比较当前节点安装摄像头和当前节点不安装摄像头（如果当前节点不安装摄像头，那么它的子节点中必须有一个要安装摄像头，所以一定会选择la或ra，再加上另一棵树需要摄像头的最少情况）</span><br><span class="line">c &#x3D; min(a,lb+rb)&#x2F;&#x2F;因为不考虑当前节点是否被监控，所以我们只需要判断两个子树需要最少摄像头的和即可（之所以和a比较是因为存在当前节点为叶子（空）节点的情况，下面会继续讨论）</span><br></pre></td></tr></table></figure>
<p>那么如果当前节点为叶子节点呢？继续向下找的话，它的子节点都是空节点，空节点不能处于被选中的状态，所以空节点不存在a状态（即当前节点被选中安装摄像头）。但是为了方便递归回溯，我们采用统一的格式，所以为了避免出现错误的给空节点设置成a的情况，我们可以将空节点的初值调成特别大，这样就解决了空节点不能被选中的情况。</p>
<p>解决了这几个关键的问题，整个问题也就迎刃而解了，附一个代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">status</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">int</span> a,b,c;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">status <span class="title">dfs</span><span class="params">(TreeNode *node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="number">999999</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> [la,lb,lc] = dfs(node-&gt;left);</span><br><span class="line">        <span class="keyword">auto</span> [ra,rb,rc] = dfs(node-&gt;right);</span><br><span class="line">        <span class="keyword">int</span> a = lc+rc+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="built_in">min</span>(a,<span class="built_in">min</span>(ra+lb,rb+la));</span><br><span class="line">        <span class="keyword">int</span> c = <span class="built_in">min</span>(a,lb+rb);</span><br><span class="line">        <span class="comment">//cout &lt;&lt; a &lt;&lt; b &lt;&lt; c &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">return</span> &#123;a,b,c&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCameraCover</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> [a,b,c] = dfs(root);</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>回溯</tag>
        <tag>树状动归</tag>
      </tags>
  </entry>
  <entry>
    <title>红黑树</title>
    <url>/2020/09/15/%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
    <content><![CDATA[<p>最近学习数据结构和c++的STL，了解到了map、set的实现都是依靠红黑树，依靠红黑树的这两个容器都有查找速度快，插入删除元素快的特点，下面记录一下红黑树的原理及实现。</p>
<a id="more"></a>
<p><a href="https://www.jianshu.com/p/e136ec79235c" target="_blank" rel="noopener">参考链接</a></p>
<p>红黑树本质上也是一个平衡二叉树，但是它并不是严格意义上的完全平衡二叉树（AVL），而是黑色节点平衡二叉树。</p>
<h3 id="红黑树的几个性质："><a href="#红黑树的几个性质：" class="headerlink" title="红黑树的几个性质："></a>红黑树的几个性质：</h3><ul>
<li>树中只有红色或黑色的节点（每个节点不是红色就是黑色）</li>
<li>根节点是黑色节点</li>
<li>每个叶子节点（NIL）是黑色节点（NIL可以看作是空的叶子节点）</li>
<li>每个红色节点的两个子节点都是黑色</li>
<li>任意节点到每个叶子节点的路径都包含相同数量的黑节点</li>
</ul>
<p>红黑树的查找和普通的二叉树一样，但又因为红黑树总能保证黑色平衡，时间复杂度就为O(2logn)，所以查找的速度很快。</p>
<p>红黑树的插入、删除速度也很快。在c++中，由红黑树构成的数据结构（map、set、multimap、multiset）在插入或者删除操作时不需要操作内存，当插入或删除操作后，它对应的迭代器（itrator）也不需要重新声明，究其原因是因为当进行插入/删除操作时，本质上只是指针的指向进行了改变，而容器内储存的仅仅是节点的关系，而不是真正的数据。新节点也只是加了一个额外的指针进行指向，所以迭代器也可以正常继续使用。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>红黑树</tag>
      </tags>
  </entry>
  <entry>
    <title>组合总和Ⅱ</title>
    <url>/2020/09/11/%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E2%85%A1/</url>
    <content><![CDATA[<h2 id="Leetcode-40"><a href="#Leetcode-40" class="headerlink" title="Leetcode#40"></a>Leetcode#40</h2><a id="more"></a>
<h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><p>给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p>
<p>candidates 中的每个数字在每个组合中只能使用一次。</p>
<p>说明：</p>
<p>所有数字（包括目标数）都是正整数。<br>解集不能包含重复的组合。<br>来源：力扣（LeetCode）<br><a href="https://leetcode-cn.com/problems/combination-sum-ii" target="_blank" rel="noopener">链接</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;ans;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;temp;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates,<span class="keyword">int</span> target,<span class="keyword">int</span> pos,<span class="keyword">int</span> sum)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum == target)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; ans.<span class="built_in">size</span>() ; i ++)<span class="comment">//判断当前找到的vector是否已经存在了</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(temp == ans[i])</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(temp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum &gt; target)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(pos &gt;= candidates.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        temp.push_back(candidates[pos]);</span><br><span class="line">        dfs(candidates,target,pos+<span class="number">1</span>,sum+candidates[pos]);</span><br><span class="line">        temp.pop_back();</span><br><span class="line">        dfs(candidates,target,pos+<span class="number">1</span>,sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">combinationSum2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        sort(candidates.<span class="built_in">begin</span>(),candidates.<span class="built_in">end</span>());<span class="comment">//首先对数组进行排序</span></span><br><span class="line">        dfs(candidates,target,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这本来是一道很简单的递归回溯问题，但是因为题目要求不能包含重复的题解，所以对于我这个菜鸡一下就难了起来…通过对stl库的了解发现，sort是可以直接用来排序简单形式的vector的（按照字典序排列），且vector本身是可以使用标准运算符（如== &gt; &lt;等等进行比较的，仅限简单数据类型）<br>（鸽了好久的博客终于要开始更了）<br><del>（咕咕咕）</del></p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>回溯</tag>
        <tag>vector</tag>
      </tags>
  </entry>
  <entry>
    <title>解数独</title>
    <url>/2020/09/15/%E8%A7%A3%E6%95%B0%E7%8B%AC/</url>
    <content><![CDATA[<h2 id="LeetCode-37"><a href="#LeetCode-37" class="headerlink" title="LeetCode#37"></a>LeetCode#37</h2><a id="more"></a>
<p><a href="https://leetcode-cn.com/problems/sudoku-solver/" target="_blank" rel="noopener">题目链接</a></p>
<p>一道暴力的深搜就能过的题，按照数独的规则，在安放一个数的时候需要分别考虑横向、纵向以及当前位置所在的九宫格。我们可以先遍历一遍题目给出的图，分别统计出空格的位置，每一行、每一列以及每个小九宫格中已经存在的数据，然后以空格数量作为循环变量，当空格没有全部用完则继续往下一层递归，直到找到所有答案为止。为了提高递归回溯的速度，我们还可以设置一个标记判断是否已经找到其中一种解，只要找到了则停止递归。<br>附上代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">bool</span> <span class="built_in">line</span>[<span class="number">9</span>][<span class="number">9</span>];<span class="comment">//行标记数组，第一维代表是第几行，第二维代表这个数字是否存在，下面两个数组相同</span></span><br><span class="line">    <span class="keyword">bool</span> col[<span class="number">9</span>][<span class="number">9</span>];<span class="comment">//列标记数组</span></span><br><span class="line">    <span class="keyword">bool</span> flag[<span class="number">3</span>][<span class="number">3</span>][<span class="number">9</span>];<span class="comment">//九宫格标记数组</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt;nums;<span class="comment">//储存所有需要填数字的空格</span></span><br><span class="line">    <span class="keyword">bool</span> ans = <span class="literal">false</span>;<span class="comment">//判断是否已经找到一个答案的标记</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board,<span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos &gt;= nums.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            ans = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> [x,y] = nums[pos];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">9</span> ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="keyword">if</span>(!<span class="built_in">line</span>[x][i] &amp;&amp; !col[y][i] &amp;&amp; !flag[x/<span class="number">3</span>][y/<span class="number">3</span>][i] &amp;&amp; !ans)</span><br><span class="line">           &#123;</span><br><span class="line">               board[x][y] = i + <span class="number">1</span> + <span class="string">'0'</span>;</span><br><span class="line">               <span class="built_in">line</span>[x][i] = col[y][i] = flag[x/<span class="number">3</span>][y/<span class="number">3</span>][i] = <span class="literal">true</span>;</span><br><span class="line">               dfs(board,pos+<span class="number">1</span>);</span><br><span class="line">               <span class="built_in">line</span>[x][i] = col[y][i] = flag[x/<span class="number">3</span>][y/<span class="number">3</span>][i] = <span class="literal">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">9</span> ; i++)<span class="comment">//先遍历一遍数组找到所有已知信息</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; <span class="number">9</span> ; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">'.'</span>)</span><br><span class="line">                    nums.push_back(pair(i,j));</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">int</span> num = board[i][j]-<span class="string">'0'</span><span class="number">-1</span>;<span class="comment">//存储表是从0开始，所以需要减1</span></span><br><span class="line">                        <span class="built_in">line</span>[i][num] = <span class="literal">true</span>;</span><br><span class="line">                        col[j][num] = <span class="literal">true</span>;</span><br><span class="line">                        flag[i/<span class="number">3</span>][j/<span class="number">3</span>][num] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(board,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>深搜</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
</search>
